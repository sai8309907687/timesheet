{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Documents/react-project/timesheet/node_modules/@preact/signals-core/dist/signals-core.module.js","sources":["file:///Users/saireddy/Documents/react-project/timesheet/node_modules/%40preact/signals-core/src/index.ts"],"sourcesContent":["// An named symbol/brand for detecting Signal instances even when they weren't\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for(\"preact-signals\");\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n\t// A source whose value the target depends on.\n\t_source: Signal;\n\t_prevSource?: Node;\n\t_nextSource?: Node;\n\n\t// A target that depends on the source and should be notified when the source changes.\n\t_target: Computed | Effect;\n\t_prevTarget?: Node;\n\t_nextTarget?: Node;\n\n\t// The version number of the source that target has last seen. We use version numbers\n\t// instead of storing the source value, because source values can take arbitrary amount\n\t// of memory, and computeds could hang on to them forever because they're lazily evaluated.\n\t// Use the special value -1 to mark potentially unused but recyclable nodes.\n\t_version: number;\n\n\t// Used to remember & roll back the source's previous `._node` value when entering &\n\t// exiting a new evaluation context.\n\t_rollbackNode?: Node;\n};\n\nfunction startBatch() {\n\tbatchDepth++;\n}\n\nfunction endBatch() {\n\tif (batchDepth > 1) {\n\t\tbatchDepth--;\n\t\treturn;\n\t}\n\n\tlet error: unknown;\n\tlet hasError = false;\n\n\twhile (batchedEffect !== undefined) {\n\t\tlet effect: Effect | undefined = batchedEffect;\n\t\tbatchedEffect = undefined;\n\n\t\tbatchIteration++;\n\n\t\twhile (effect !== undefined) {\n\t\t\tconst next: Effect | undefined = effect._nextBatchedEffect;\n\t\t\teffect._nextBatchedEffect = undefined;\n\t\t\teffect._flags &= ~NOTIFIED;\n\n\t\t\tif (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n\t\t\t\ttry {\n\t\t\t\t\teffect._callback();\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!hasError) {\n\t\t\t\t\t\terror = err;\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\teffect = next;\n\t\t}\n\t}\n\tbatchIteration = 0;\n\tbatchDepth--;\n\n\tif (hasError) {\n\t\tthrow error;\n\t}\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n\tif (batchDepth > 0) {\n\t\treturn fn();\n\t}\n\t/*@__INLINE__**/ startBatch();\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tendBatch();\n\t}\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tevalContext = prevContext;\n\t}\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n\tif (evalContext === undefined) {\n\t\treturn undefined;\n\t}\n\n\tlet node = signal._node;\n\tif (node === undefined || node._target !== evalContext) {\n\t\t/**\n\t\t * `signal` is a new dependency. Create a new dependency node, and set it\n\t\t * as the tail of the current context's dependency list. e.g:\n\t\t *\n\t\t * { A <-> B       }\n\t\t *         ↑     ↑\n\t\t *        tail  node (new)\n\t\t *               ↓\n\t\t * { A <-> B <-> C }\n\t\t *               ↑\n\t\t *              tail (evalContext._sources)\n\t\t */\n\t\tnode = {\n\t\t\t_version: 0,\n\t\t\t_source: signal,\n\t\t\t_prevSource: evalContext._sources,\n\t\t\t_nextSource: undefined,\n\t\t\t_target: evalContext,\n\t\t\t_prevTarget: undefined,\n\t\t\t_nextTarget: undefined,\n\t\t\t_rollbackNode: node,\n\t\t};\n\n\t\tif (evalContext._sources !== undefined) {\n\t\t\tevalContext._sources._nextSource = node;\n\t\t}\n\t\tevalContext._sources = node;\n\t\tsignal._node = node;\n\n\t\t// Subscribe to change notifications from this dependency if we're in an effect\n\t\t// OR evaluating a computed signal that in turn has subscribers.\n\t\tif (evalContext._flags & TRACKING) {\n\t\t\tsignal._subscribe(node);\n\t\t}\n\t\treturn node;\n\t} else if (node._version === -1) {\n\t\t// `signal` is an existing dependency from a previous evaluation. Reuse it.\n\t\tnode._version = 0;\n\n\t\t/**\n\t\t * If `node` is not already the current tail of the dependency list (i.e.\n\t\t * there is a next node in the list), then make the `node` the new tail. e.g:\n\t\t *\n\t\t * { A <-> B <-> C <-> D }\n\t\t *         ↑           ↑\n\t\t *        node   ┌─── tail (evalContext._sources)\n\t\t *         └─────│─────┐\n\t\t *               ↓     ↓\n\t\t * { A <-> C <-> D <-> B }\n\t\t *                     ↑\n\t\t *                    tail (evalContext._sources)\n\t\t */\n\t\tif (node._nextSource !== undefined) {\n\t\t\tnode._nextSource._prevSource = node._prevSource;\n\n\t\t\tif (node._prevSource !== undefined) {\n\t\t\t\tnode._prevSource._nextSource = node._nextSource;\n\t\t\t}\n\n\t\t\tnode._prevSource = evalContext._sources;\n\t\t\tnode._nextSource = undefined;\n\n\t\t\tevalContext._sources!._nextSource = node;\n\t\t\tevalContext._sources = node;\n\t\t}\n\n\t\t// We can assume that the currently evaluated effect / computed signal is already\n\t\t// subscribed to change notifications from `signal` if needed.\n\t\treturn node;\n\t}\n\treturn undefined;\n}\n\n//#region Signal\n\n/**\n * The base class for plain and computed signals.\n */\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style prototypes.\n// This enables better control of the transpiled output size.\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\ndeclare class Signal<T = any> {\n\t/** @internal */\n\t_value: unknown;\n\n\t/**\n\t * @internal\n\t * Version numbers should always be >= 0, because the special value -1 is used\n\t * by Nodes to signify potentially unused but recyclable nodes.\n\t */\n\t_version: number;\n\n\t/** @internal */\n\t_node?: Node;\n\n\t/** @internal */\n\t_targets?: Node;\n\n\tconstructor(value?: T, options?: SignalOptions<T>);\n\n\t/** @internal */\n\t_refresh(): boolean;\n\n\t/** @internal */\n\t_subscribe(node: Node): void;\n\n\t/** @internal */\n\t_unsubscribe(node: Node): void;\n\n\t/** @internal */\n\t_watched?(this: Signal<T>): void;\n\n\t/** @internal */\n\t_unwatched?(this: Signal<T>): void;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\n\tname?: string;\n\n\tvalueOf(): T;\n\n\ttoString(): string;\n\n\ttoJSON(): T;\n\n\tpeek(): T;\n\n\tbrand: typeof BRAND_SYMBOL;\n\n\tget value(): T;\n\tset value(value: T);\n}\n\nexport interface SignalOptions<T = any> {\n\twatched?: (this: Signal<T>) => void;\n\tunwatched?: (this: Signal<T>) => void;\n\tname?: string;\n}\n\n/** @internal */\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style prototypes.\n// This enables better control of the transpiled output size.\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\nfunction Signal(this: Signal, value?: unknown, options?: SignalOptions) {\n\tthis._value = value;\n\tthis._version = 0;\n\tthis._node = undefined;\n\tthis._targets = undefined;\n\tthis._watched = options?.watched;\n\tthis._unwatched = options?.unwatched;\n\tthis.name = options?.name;\n}\n\nSignal.prototype.brand = BRAND_SYMBOL;\n\nSignal.prototype._refresh = function () {\n\treturn true;\n};\n\nSignal.prototype._subscribe = function (node) {\n\tconst targets = this._targets;\n\tif (targets !== node && node._prevTarget === undefined) {\n\t\tnode._nextTarget = targets;\n\t\tthis._targets = node;\n\n\t\tif (targets !== undefined) {\n\t\t\ttargets._prevTarget = node;\n\t\t} else {\n\t\t\tuntracked(() => {\n\t\t\t\tthis._watched?.call(this);\n\t\t\t});\n\t\t}\n\t}\n};\n\nSignal.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the signal has any subscribers to begin with.\n\tif (this._targets !== undefined) {\n\t\tconst prev = node._prevTarget;\n\t\tconst next = node._nextTarget;\n\t\tif (prev !== undefined) {\n\t\t\tprev._nextTarget = next;\n\t\t\tnode._prevTarget = undefined;\n\t\t}\n\n\t\tif (next !== undefined) {\n\t\t\tnext._prevTarget = prev;\n\t\t\tnode._nextTarget = undefined;\n\t\t}\n\n\t\tif (node === this._targets) {\n\t\t\tthis._targets = next;\n\t\t\tif (next === undefined) {\n\t\t\t\tuntracked(() => {\n\t\t\t\t\tthis._unwatched?.call(this);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n};\n\nSignal.prototype.subscribe = function (fn) {\n\treturn effect(\n\t\t() => {\n\t\t\tconst value = this.value;\n\t\t\tconst prevContext = evalContext;\n\t\t\tevalContext = undefined;\n\t\t\ttry {\n\t\t\t\tfn(value);\n\t\t\t} finally {\n\t\t\t\tevalContext = prevContext;\n\t\t\t}\n\t\t},\n\t\t{ name: \"sub\" }\n\t);\n};\n\nSignal.prototype.valueOf = function () {\n\treturn this.value;\n};\n\nSignal.prototype.toString = function () {\n\treturn this.value + \"\";\n};\n\nSignal.prototype.toJSON = function () {\n\treturn this.value;\n};\n\nSignal.prototype.peek = function () {\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\ttry {\n\t\treturn this.value;\n\t} finally {\n\t\tevalContext = prevContext;\n\t}\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n\tget(this: Signal) {\n\t\tconst node = addDependency(this);\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\treturn this._value;\n\t},\n\tset(this: Signal, value) {\n\t\tif (value !== this._value) {\n\t\t\tif (batchIteration > 100) {\n\t\t\t\tthrow new Error(\"Cycle detected\");\n\t\t\t}\n\n\t\t\tthis._value = value;\n\t\t\tthis._version++;\n\t\t\tglobalVersion++;\n\n\t\t\t/**@__INLINE__*/ startBatch();\n\t\t\ttry {\n\t\t\t\tfor (\n\t\t\t\t\tlet node = this._targets;\n\t\t\t\t\tnode !== undefined;\n\t\t\t\t\tnode = node._nextTarget\n\t\t\t\t) {\n\t\t\t\t\tnode._target._notify();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tendBatch();\n\t\t\t}\n\t\t}\n\t},\n});\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T, options?: SignalOptions<T>): Signal<T>;\nexport function signal<T = undefined>(): Signal<T | undefined>;\nexport function signal<T>(value?: T, options?: SignalOptions<T>): Signal<T> {\n\treturn new Signal(value, options);\n}\n\n//#endregion Signal\n\n//#region Computed\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n\t// Check the dependencies for changed values. The dependency list is already\n\t// in order of use. Therefore if multiple dependencies have changed values, only\n\t// the first used dependency is re-evaluated at this point.\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tif (\n\t\t\t// If the dependency has definitely been updated since its version number\n\t\t\t// was observed, then we need to recompute. This first check is not strictly\n\t\t\t// necessary for correctness, but allows us to skip the refresh call if the\n\t\t\t// dependency has already been updated.\n\t\t\tnode._source._version !== node._version ||\n\t\t\t// Refresh the dependency. If there's something blocking the refresh (e.g. a\n\t\t\t// dependency cycle), then we need to recompute.\n\t\t\t!node._source._refresh() ||\n\t\t\t// If the dependency got a new version after the refresh, then we need to recompute.\n\t\t\tnode._source._version !== node._version\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t// If none of the dependencies have changed values since last recompute then\n\t// there's no need to recompute.\n\treturn false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n\t/**\n\t * 1. Mark all current sources as re-usable nodes (version: -1)\n\t * 2. Set a rollback node if the current node is being used in a different context\n\t * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n\t *\n\t *    { undefined <- A <-> B <-> C -> undefined }\n\t *                   ↑           ↑\n\t *                   │           └──────┐\n\t * target._sources = A; (node is head)  │\n\t *                   ↓                  │\n\t * target._sources = C; (node is tail) ─┘\n\t */\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tconst rollbackNode = node._source._node;\n\t\tif (rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = rollbackNode;\n\t\t}\n\t\tnode._source._node = node;\n\t\tnode._version = -1;\n\n\t\tif (node._nextSource === undefined) {\n\t\t\ttarget._sources = node;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n\tlet node = target._sources;\n\tlet head: Node | undefined = undefined;\n\n\t/**\n\t * At this point 'target._sources' points to the tail of the doubly-linked list.\n\t * It contains all existing sources + new sources in order of use.\n\t * Iterate backwards until we find the head node while dropping old dependencies.\n\t */\n\twhile (node !== undefined) {\n\t\tconst prev = node._prevSource;\n\n\t\t/**\n\t\t * The node was not re-used, unsubscribe from its change notifications and remove itself\n\t\t * from the doubly-linked list. e.g:\n\t\t *\n\t\t * { A <-> B <-> C }\n\t\t *         ↓\n\t\t *    { A <-> C }\n\t\t */\n\t\tif (node._version === -1) {\n\t\t\tnode._source._unsubscribe(node);\n\n\t\t\tif (prev !== undefined) {\n\t\t\t\tprev._nextSource = node._nextSource;\n\t\t\t}\n\t\t\tif (node._nextSource !== undefined) {\n\t\t\t\tnode._nextSource._prevSource = prev;\n\t\t\t}\n\t\t} else {\n\t\t\t/**\n\t\t\t * The new head is the last node seen which wasn't removed/unsubscribed\n\t\t\t * from the doubly-linked list. e.g:\n\t\t\t *\n\t\t\t * { A <-> B <-> C }\n\t\t\t *   ↑     ↑     ↑\n\t\t\t *   │     │     └ head = node\n\t\t\t *   │     └ head = node\n\t\t\t *   └ head = node\n\t\t\t */\n\t\t\thead = node;\n\t\t}\n\n\t\tnode._source._node = node._rollbackNode;\n\t\tif (node._rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = undefined;\n\t\t}\n\n\t\tnode = prev;\n\t}\n\n\ttarget._sources = head;\n}\n\n/**\n * The base class for computed signals.\n */\ndeclare class Computed<T = any> extends Signal<T> {\n\t_fn: () => T;\n\t_sources?: Node;\n\t_globalVersion: number;\n\t_flags: number;\n\n\tconstructor(fn: () => T, options?: SignalOptions<T>);\n\n\t_notify(): void;\n\tget value(): T;\n}\n\n/** @internal */\nfunction Computed(this: Computed, fn: () => unknown, options?: SignalOptions) {\n\tSignal.call(this, undefined);\n\n\tthis._fn = fn;\n\tthis._sources = undefined;\n\tthis._globalVersion = globalVersion - 1;\n\tthis._flags = OUTDATED;\n\tthis._watched = options?.watched;\n\tthis._unwatched = options?.unwatched;\n\tthis.name = options?.name;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n\tthis._flags &= ~NOTIFIED;\n\n\tif (this._flags & RUNNING) {\n\t\treturn false;\n\t}\n\n\t// If this computed signal has subscribed to updates from its dependencies\n\t// (TRACKING flag set) and none of them have notified about changes (OUTDATED\n\t// flag not set), then the computed value can't have changed.\n\tif ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n\t\treturn true;\n\t}\n\tthis._flags &= ~OUTDATED;\n\n\tif (this._globalVersion === globalVersion) {\n\t\treturn true;\n\t}\n\tthis._globalVersion = globalVersion;\n\n\t// Mark this computed signal running before checking the dependencies for value\n\t// changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n\tthis._flags |= RUNNING;\n\tif (this._version > 0 && !needsToRecompute(this)) {\n\t\tthis._flags &= ~RUNNING;\n\t\treturn true;\n\t}\n\n\tconst prevContext = evalContext;\n\ttry {\n\t\tprepareSources(this);\n\t\tevalContext = this;\n\t\tconst value = this._fn();\n\t\tif (\n\t\t\tthis._flags & HAS_ERROR ||\n\t\t\tthis._value !== value ||\n\t\t\tthis._version === 0\n\t\t) {\n\t\t\tthis._value = value;\n\t\t\tthis._flags &= ~HAS_ERROR;\n\t\t\tthis._version++;\n\t\t}\n\t} catch (err) {\n\t\tthis._value = err;\n\t\tthis._flags |= HAS_ERROR;\n\t\tthis._version++;\n\t}\n\tevalContext = prevContext;\n\tcleanupSources(this);\n\tthis._flags &= ~RUNNING;\n\treturn true;\n};\n\nComputed.prototype._subscribe = function (node) {\n\tif (this._targets === undefined) {\n\t\tthis._flags |= OUTDATED | TRACKING;\n\n\t\t// A computed signal subscribes lazily to its dependencies when it\n\t\t// gets its first subscriber.\n\t\tfor (\n\t\t\tlet node = this._sources;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextSource\n\t\t) {\n\t\t\tnode._source._subscribe(node);\n\t\t}\n\t}\n\tSignal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the computed signal has any subscribers.\n\tif (this._targets !== undefined) {\n\t\tSignal.prototype._unsubscribe.call(this, node);\n\n\t\t// Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n\t\t// This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n\t\tif (this._targets === undefined) {\n\t\t\tthis._flags &= ~TRACKING;\n\n\t\t\tfor (\n\t\t\t\tlet node = this._sources;\n\t\t\t\tnode !== undefined;\n\t\t\t\tnode = node._nextSource\n\t\t\t) {\n\t\t\t\tnode._source._unsubscribe(node);\n\t\t\t}\n\t\t}\n\t}\n};\n\nComputed.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= OUTDATED | NOTIFIED;\n\n\t\tfor (\n\t\t\tlet node = this._targets;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextTarget\n\t\t) {\n\t\t\tnode._target._notify();\n\t\t}\n\t}\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n\tget(this: Computed) {\n\t\tif (this._flags & RUNNING) {\n\t\t\tthrow new Error(\"Cycle detected\");\n\t\t}\n\t\tconst node = addDependency(this);\n\t\tthis._refresh();\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\tif (this._flags & HAS_ERROR) {\n\t\t\tthrow this._value;\n\t\t}\n\t\treturn this._value;\n\t},\n});\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n\treadonly value: T;\n\tpeek(): T;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\tvalueOf(): T;\n\ttoString(): string;\n\ttoJSON(): T;\n\tbrand: typeof BRAND_SYMBOL;\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(\n\tfn: () => T,\n\toptions?: SignalOptions<T>\n): ReadonlySignal<T> {\n\treturn new Computed(fn, options);\n}\n\n//#endregion Computed\n\n//#region Effect\n\nfunction cleanupEffect(effect: Effect) {\n\tconst cleanup = effect._cleanup;\n\teffect._cleanup = undefined;\n\n\tif (typeof cleanup === \"function\") {\n\t\t/*@__INLINE__**/ startBatch();\n\n\t\t// Run cleanup functions always outside of any context.\n\t\tconst prevContext = evalContext;\n\t\tevalContext = undefined;\n\t\ttry {\n\t\t\tcleanup();\n\t\t} catch (err) {\n\t\t\teffect._flags &= ~RUNNING;\n\t\t\teffect._flags |= DISPOSED;\n\t\t\tdisposeEffect(effect);\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tevalContext = prevContext;\n\t\t\tendBatch();\n\t\t}\n\t}\n}\n\nfunction disposeEffect(effect: Effect) {\n\tfor (\n\t\tlet node = effect._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tnode._source._unsubscribe(node);\n\t}\n\teffect._fn = undefined;\n\teffect._sources = undefined;\n\n\tcleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n\tif (evalContext !== this) {\n\t\tthrow new Error(\"Out-of-order effect\");\n\t}\n\tcleanupSources(this);\n\tevalContext = prevContext;\n\n\tthis._flags &= ~RUNNING;\n\tif (this._flags & DISPOSED) {\n\t\tdisposeEffect(this);\n\t}\n\tendBatch();\n}\n\ntype EffectFn =\n\t| ((this: { dispose: () => void }) => void | (() => void))\n\t| (() => void | (() => void));\n\n/**\n * The base class for reactive effects.\n */\ndeclare class Effect {\n\t_fn?: EffectFn;\n\t_cleanup?: () => void;\n\t_sources?: Node;\n\t_nextBatchedEffect?: Effect;\n\t_flags: number;\n\t_debugCallback?: () => void;\n\tname?: string;\n\n\tconstructor(fn: EffectFn, options?: EffectOptions);\n\n\t_callback(): void;\n\t_start(): () => void;\n\t_notify(): void;\n\t_dispose(): void;\n\tdispose(): void;\n}\n\nexport interface EffectOptions {\n\tname?: string;\n}\n\nlet capturedEffects: Effect[] | undefined;\n\n/** @internal */\nfunction Effect(this: Effect, fn: EffectFn, options?: EffectOptions) {\n\tthis._fn = fn;\n\tthis._cleanup = undefined;\n\tthis._sources = undefined;\n\tthis._nextBatchedEffect = undefined;\n\tthis._flags = TRACKING;\n\tthis.name = options?.name;\n\n\tif (capturedEffects) {\n\t\tcapturedEffects.push(this);\n\t}\n}\n\nEffect.prototype._callback = function () {\n\tconst finish = this._start();\n\ttry {\n\t\tif (this._flags & DISPOSED) return;\n\t\tif (this._fn === undefined) return;\n\n\t\tconst cleanup = this._fn();\n\t\tif (typeof cleanup === \"function\") {\n\t\t\tthis._cleanup = cleanup;\n\t\t}\n\t} finally {\n\t\tfinish();\n\t}\n};\n\nEffect.prototype._start = function () {\n\tif (this._flags & RUNNING) {\n\t\tthrow new Error(\"Cycle detected\");\n\t}\n\tthis._flags |= RUNNING;\n\tthis._flags &= ~DISPOSED;\n\tcleanupEffect(this);\n\tprepareSources(this);\n\n\t/*@__INLINE__**/ startBatch();\n\tconst prevContext = evalContext;\n\tevalContext = this;\n\treturn endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= NOTIFIED;\n\t\tthis._nextBatchedEffect = batchedEffect;\n\t\tbatchedEffect = this;\n\t}\n};\n\nEffect.prototype._dispose = function () {\n\tthis._flags |= DISPOSED;\n\n\tif (!(this._flags & RUNNING)) {\n\t\tdisposeEffect(this);\n\t}\n};\n\nEffect.prototype.dispose = function () {\n\tthis._dispose();\n};\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn, options?: EffectOptions): () => void {\n\tconst effect = new Effect(fn, options);\n\ttry {\n\t\teffect._callback();\n\t} catch (err) {\n\t\teffect._dispose();\n\t\tthrow err;\n\t}\n\t// Return a bound function instead of a wrapper like `() => effect._dispose()`,\n\t// because bound functions seem to be just as fast and take up a lot less memory.\n\tconst dispose = effect._dispose.bind(effect);\n\t(dispose as any)[Symbol.dispose] = dispose;\n\treturn dispose as any;\n}\n\n//#endregion Effect\n\n//#region Action\n\nfunction action<TArgs extends unknown[], TReturn>(\n\tfn: (...args: TArgs) => TReturn\n): (...args: TArgs) => TReturn {\n\treturn function actionWrapper(this: unknown, ...args: TArgs) {\n\t\treturn batch(() => untracked(() => fn.apply(this, args)));\n\t};\n}\n\n//#endregion Action\n\n//#region createModel\n\n/** Models should only contain signals, actions, and nested objects containing only signals and actions. */\ntype ValidateModel<TModel> = {\n\t[Key in keyof TModel]: TModel[Key] extends ReadonlySignal<unknown>\n\t\t? TModel[Key]\n\t\t: TModel[Key] extends (...args: any[]) => any\n\t\t\t? TModel[Key]\n\t\t\t: TModel[Key] extends object\n\t\t\t\t? ValidateModel<TModel[Key]>\n\t\t\t\t: `Property ${Key extends string ? `'${Key}' ` : \"\"}is not a Signal, Action, or an object that contains only Signals and Actions.`;\n};\n\nexport type Model<TModel> = ValidateModel<TModel> & Disposable;\n\nexport type ModelFactory<TModel, TFactoryArgs extends any[] = []> = (\n\t...args: TFactoryArgs\n) => ValidateModel<TModel>;\nexport type ModelConstructor<TModel, TFactoryArgs extends any[] = []> = new (\n\t...args: TFactoryArgs\n) => Model<TModel>;\n\n/**\n * The public types for ModelConstructor require using `new` to help\n * disambiguate the function passed into `createModel` and the returned\n * constructor function. It is easier to say that `createModel` accepts\n * a factory and returns a class, then to say it accepts a factory and\n * returns a factory. In other words, this example:\n *\n * ```ts\n * const PersonModel = createModel((name: string) => ({ ... }));\n * const person = new PersonModel(\"John\");\n * ```\n *\n * is easier to understand than this example:\n *\n * ```ts\n * const createPerson = createModel((name: string) => ({ ... }));\n * const person = createPerson(\"John\");\n * ```\n *\n * However, internally we implement `createModel` to return a function\n * that can be called without `new` for simplicity. To bridge the gap\n * between the public types and the internal implementation, we define\n * this internal interface that extends the public interface but also\n * allows calling without `new`.\n *\n * This pattern is used by the Preact & React adapters to make instantiating\n * a model or a function that returns a model easier.\n *\n * @internal\n */\ninterface InternalModelConstructor<TModel, TFactoryArgs extends any[]>\n\textends ModelConstructor<TModel, TFactoryArgs> {\n\t(...args: TFactoryArgs): Model<TModel>;\n}\n\nfunction startCapturingEffects(): () => Effect[] | undefined {\n\tlet prevCapturedEffects = capturedEffects;\n\tcapturedEffects = [];\n\n\treturn function stopCapturingEffects() {\n\t\tlet modelEffects = capturedEffects;\n\t\tif (capturedEffects && prevCapturedEffects) {\n\t\t\tprevCapturedEffects = prevCapturedEffects.concat(capturedEffects);\n\t\t}\n\n\t\tcapturedEffects = prevCapturedEffects;\n\n\t\treturn modelEffects;\n\t};\n}\n\nfunction createModel<TModel, TFactoryArgs extends any[] = []>(\n\tmodelFactory: ModelFactory<TModel, TFactoryArgs>\n): ModelConstructor<TModel, TFactoryArgs> {\n\treturn function SignalModel(...args: TFactoryArgs): Model<TModel> {\n\t\tlet modelEffects: Effect[] | undefined;\n\t\tlet model: Model<TModel>;\n\n\t\tconst stopCapturingEffects = startCapturingEffects();\n\t\ttry {\n\t\t\tmodel = modelFactory(...args) as Model<TModel>;\n\t\t} catch (err) {\n\t\t\t// Drop any captured effects on error. Errors from nested models will bubble\n\t\t\t// up here and recursively reset `capturedEffects` to `undefined` preventing\n\t\t\t// any captured effects from leaking\n\t\t\tcapturedEffects = undefined;\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tmodelEffects = stopCapturingEffects();\n\t\t}\n\n\t\tfor (const key in model) {\n\t\t\t// @ts-expect-error TypeScript can't infer that model[key] is a valid here\n\t\t\tif (typeof model[key] === \"function\") {\n\t\t\t\t// @ts-expect-error TypeScript can't infer that model[key] is a valid function\n\t\t\t\t// to pass to action here\n\t\t\t\tmodel[key] = action(model[key]);\n\t\t\t}\n\t\t}\n\n\t\tmodel[Symbol.dispose] = action(function disposeModel() {\n\t\t\tif (modelEffects) {\n\t\t\t\tfor (let i = 0; i < modelEffects.length; i++) {\n\t\t\t\t\tmodelEffects[i].dispose();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmodelEffects = undefined;\n\t\t});\n\n\t\treturn model;\n\t} as InternalModelConstructor<TModel, TFactoryArgs>;\n}\n\n//#endregion createModel\n\nexport {\n\tcomputed,\n\teffect,\n\tbatch,\n\tuntracked,\n\taction,\n\tcreateModel,\n\tSignal,\n\tReadonlySignal,\n\tEffect,\n\tComputed,\n};\n"],"names":["BRAND_SYMBOL","Symbol","endBatch","batchDepth","error","hasError","undefined","batchedEffect","effect","batchIteration","next","_nextBatchedEffect","_flags","needsToRecompute","_callback","err","batch","fn","evalContext","untracked","prevContext","capturedEffects","globalVersion","addDependency","signal","node","_node","_target","_version","_source","_prevSource","_sources","_nextSource","_prevTarget","_nextTarget","_rollbackNode","_subscribe","Signal","value","options","this","_value","_targets","_watched","watched","_unwatched","unwatched","name","prototype","brand","_refresh","_this","targets","_this$_watched","call","_unsubscribe","_this2","prev","_this2$_unwatched","subscribe","_this3","valueOf","toString","toJSON","peek","Object","defineProperty","get","set","Error","_notify","target","prepareSources","rollbackNode","cleanupSources","head","Computed","_fn","_globalVersion","OUTDATED","computed","cleanupEffect","cleanup","_cleanup","disposeEffect","endEffect","Effect","push","finish","_start","bind","_dispose","dispose","action","_arguments","arguments","_this4","apply","slice","startCapturingEffects","prevCapturedEffects","modelEffects","concat","createModel","modelFactory","model","stopCapturingEffects","key","i","length"],"mappings":"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"}},
    {"offset": {"line": 454, "column": 0}, "map": {"version":3,"sources":["file:///Users/saireddy/Documents/react-project/timesheet/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"],"sourcesContent":["/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    function useSyncExternalStore$2(subscribe, getSnapshot) {\n      didWarnOld18Alpha ||\n        void 0 === React.startTransition ||\n        ((didWarnOld18Alpha = !0),\n        console.error(\n          \"You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.\"\n        ));\n      var value = getSnapshot();\n      if (!didWarnUncachedGetSnapshot) {\n        var cachedValue = getSnapshot();\n        objectIs(value, cachedValue) ||\n          (console.error(\n            \"The result of getSnapshot should be cached to avoid an infinite loop\"\n          ),\n          (didWarnUncachedGetSnapshot = !0));\n      }\n      cachedValue = useState({\n        inst: { value: value, getSnapshot: getSnapshot }\n      });\n      var inst = cachedValue[0].inst,\n        forceUpdate = cachedValue[1];\n      useLayoutEffect(\n        function () {\n          inst.value = value;\n          inst.getSnapshot = getSnapshot;\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n        },\n        [subscribe, value, getSnapshot]\n      );\n      useEffect(\n        function () {\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          return subscribe(function () {\n            checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          });\n        },\n        [subscribe]\n      );\n      useDebugValue(value);\n      return value;\n    }\n    function checkIfSnapshotChanged(inst) {\n      var latestGetSnapshot = inst.getSnapshot;\n      inst = inst.value;\n      try {\n        var nextValue = latestGetSnapshot();\n        return !objectIs(inst, nextValue);\n      } catch (error) {\n        return !0;\n      }\n    }\n    function useSyncExternalStore$1(subscribe, getSnapshot) {\n      return getSnapshot();\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = require(\"react\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useState = React.useState,\n      useEffect = React.useEffect,\n      useLayoutEffect = React.useLayoutEffect,\n      useDebugValue = React.useDebugValue,\n      didWarnOld18Alpha = !1,\n      didWarnUncachedGetSnapshot = !1,\n      shim =\n        \"undefined\" === typeof window ||\n        \"undefined\" === typeof window.document ||\n        \"undefined\" === typeof window.document.createElement\n          ? useSyncExternalStore$1\n          : useSyncExternalStore$2;\n    exports.useSyncExternalStore =\n      void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n"],"names":[],"mappings":"AAWiB;AAXjB;;;;;;;;CAQC,GAED;AACA,oEACE,AAAC;IACC,SAAS,GAAG,CAAC,EAAE,CAAC;QACd,OAAO,AAAC,MAAM,KAAK,CAAC,MAAM,KAAK,IAAI,MAAM,IAAI,CAAC,KAAO,MAAM,KAAK,MAAM;IACxE;IACA,SAAS,uBAAuB,SAAS,EAAE,WAAW;QACpD,qBACE,KAAK,MAAM,MAAM,eAAe,IAChC,CAAC,AAAC,oBAAoB,CAAC,GACvB,QAAQ,KAAK,CACX,iMACD;QACH,IAAI,QAAQ;QACZ,IAAI,CAAC,4BAA4B;YAC/B,IAAI,cAAc;YAClB,SAAS,OAAO,gBACd,CAAC,QAAQ,KAAK,CACZ,yEAED,6BAA6B,CAAC,CAAE;QACrC;QACA,cAAc,SAAS;YACrB,MAAM;gBAAE,OAAO;gBAAO,aAAa;YAAY;QACjD;QACA,IAAI,OAAO,WAAW,CAAC,EAAE,CAAC,IAAI,EAC5B,cAAc,WAAW,CAAC,EAAE;QAC9B;sDACE;gBACE,KAAK,KAAK,GAAG;gBACb,KAAK,WAAW,GAAG;gBACnB,uBAAuB,SAAS,YAAY;oBAAE,MAAM;gBAAK;YAC3D;qDACA;YAAC;YAAW;YAAO;SAAY;QAEjC;gDACE;gBACE,uBAAuB,SAAS,YAAY;oBAAE,MAAM;gBAAK;gBACzD,OAAO;wDAAU;wBACf,uBAAuB,SAAS,YAAY;4BAAE,MAAM;wBAAK;oBAC3D;;YACF;+CACA;YAAC;SAAU;QAEb,cAAc;QACd,OAAO;IACT;IACA,SAAS,uBAAuB,IAAI;QAClC,IAAI,oBAAoB,KAAK,WAAW;QACxC,OAAO,KAAK,KAAK;QACjB,IAAI;YACF,IAAI,YAAY;YAChB,OAAO,CAAC,SAAS,MAAM;QACzB,EAAE,OAAO,OAAO;YACd,OAAO,CAAC;QACV;IACF;IACA,SAAS,uBAAuB,SAAS,EAAE,WAAW;QACpD,OAAO;IACT;IACA,gBAAgB,OAAO,kCACrB,eACE,OAAO,+BAA+B,2BAA2B,IACnE,+BAA+B,2BAA2B,CAAC;IAC7D,IAAI,yJACF,WAAW,eAAe,OAAO,OAAO,EAAE,GAAG,OAAO,EAAE,GAAG,IACzD,WAAW,MAAM,QAAQ,EACzB,YAAY,MAAM,SAAS,EAC3B,kBAAkB,MAAM,eAAe,EACvC,gBAAgB,MAAM,aAAa,EACnC,oBAAoB,CAAC,GACrB,6BAA6B,CAAC,GAC9B,OACE,gBAAgB,OAAO,UACvB,gBAAgB,OAAO,OAAO,QAAQ,IACtC,gBAAgB,OAAO,OAAO,QAAQ,CAAC,aAAa,GAChD,yBACA;IACR,QAAQ,oBAAoB,GAC1B,KAAK,MAAM,MAAM,oBAAoB,GAAG,MAAM,oBAAoB,GAAG;IACvE,gBAAgB,OAAO,kCACrB,eACE,OAAO,+BAA+B,0BAA0B,IAClE,+BAA+B,0BAA0B,CAAC;AAC9D","ignoreList":[0]}},
    {"offset": {"line": 536, "column": 0}, "map": {"version":3,"sources":["file:///Users/saireddy/Documents/react-project/timesheet/node_modules/use-sync-external-store/shim/index.js"],"sourcesContent":["'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n"],"names":[],"mappings":"AAEI;AAFJ;AAEA;;KAEO;IACL,OAAO,OAAO;AAChB","ignoreList":[0]}},
    {"offset": {"line": 547, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Documents/react-project/timesheet/node_modules/@preact/signals-react/runtime/dist/runtime.module.js","sources":["file:///Users/saireddy/Documents/react-project/timesheet/node_modules/%40preact/signals-react/runtime/src/index.ts"],"sourcesContent":["import {\n\tsignal,\n\tcomputed,\n\teffect,\n\tSignal,\n\tReadonlySignal,\n\tSignalOptions,\n\tEffectOptions,\n\ttype Model,\n\ttype ModelConstructor,\n} from \"@preact/signals-core\";\nimport {\n\tuseState,\n\tuseRef,\n\tuseMemo,\n\tuseEffect,\n\tuseLayoutEffect,\n\tversion as reactVersion,\n} from \"react\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\nimport type { SignalsDevToolsAPI } from \"../../../debug/src/devtools\";\n\nconst [major] = reactVersion.split(\".\").map(Number);\nconst Empty = [] as const;\n// V19 https://github.com/facebook/react/blob/346c7d4c43a0717302d446da9e7423a8e28d8996/packages/shared/ReactSymbols.js#L15\n// V18 https://github.com/facebook/react/blob/346c7d4c43a0717302d446da9e7423a8e28d8996/packages/shared/ReactSymbols.js#L15\nconst ReactElemType = Symbol.for(\n\tmajor >= 19 ? \"react.transitional.element\" : \"react.element\"\n);\n\nconst DEVTOOLS_ENABLED =\n\ttypeof window !== \"undefined\" && !!window.__PREACT_SIGNALS_DEVTOOLS__;\n\nexport function wrapJsx<T>(jsx: T): T {\n\tif (typeof jsx !== \"function\") return jsx;\n\n\treturn function (type: any, props: any, ...rest: any[]) {\n\t\tif (typeof type === \"string\" && props) {\n\t\t\tfor (let i in props) {\n\t\t\t\tlet v = props[i];\n\t\t\t\tif (i !== \"children\" && v instanceof Signal) {\n\t\t\t\t\tprops[i] = v.value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jsx.call(jsx, type, props, ...rest);\n\t} as any as T;\n}\n\nconst symDispose: unique symbol =\n\t(Symbol as any).dispose || Symbol.for(\"Symbol.dispose\");\n\ninterface Effect {\n\t_sources: object | undefined;\n\t_debugCallback?: () => void;\n\t_start(): () => void;\n\t_callback(): void;\n\t_dispose(): void;\n}\n\n/**\n * Use this flag to represent a bare `useSignals` call that doesn't manually\n * close its effect store and relies on auto-closing when the next useSignals is\n * called or after a microtask\n */\nconst UNMANAGED = 0;\n/**\n * Use this flag to represent a `useSignals` call that is manually closed by a\n * try/finally block in a component's render method. This is the default usage\n * that the react-transform plugin uses.\n */\nconst MANAGED_COMPONENT = 1;\n/**\n * Use this flag to represent a `useSignals` call that is manually closed by a\n * try/finally block in a hook body. This is the default usage that the\n * react-transform plugin uses.\n */\nconst MANAGED_HOOK = 2;\n\n/**\n * An enum defining how this store is used. See the documentation for each enum\n * member for more details.\n * @see {@link UNMANAGED}\n * @see {@link MANAGED_COMPONENT}\n * @see {@link MANAGED_HOOK}\n */\ntype EffectStoreUsage =\n\t| typeof UNMANAGED\n\t| typeof MANAGED_COMPONENT\n\t| typeof MANAGED_HOOK;\n\nexport interface EffectStore {\n\t/**\n\t * An enum defining how this hook is used and whether it is invoked in a\n\t * component's body or hook body. See the comment on `EffectStoreUsage` for\n\t * more details.\n\t */\n\treadonly _usage: EffectStoreUsage;\n\treadonly effect: Effect;\n\tsubscribe(onStoreChange: () => void): () => void;\n\tgetSnapshot(): number;\n\t/** startEffect - begin tracking signals used in this component */\n\t_start(): void;\n\t/** finishEffect - stop tracking the signals used in this component */\n\tf(): void;\n\t[symDispose](): void;\n}\n\nlet currentStore: EffectStore | undefined;\n\nfunction startComponentEffect(\n\tprevStore: EffectStore | undefined,\n\tnextStore: EffectStore\n) {\n\tconst endEffect = nextStore.effect._start();\n\tcurrentStore = nextStore;\n\n\treturn finishComponentEffect.bind(nextStore, prevStore, endEffect);\n}\n\nfunction finishComponentEffect(\n\tthis: EffectStore,\n\tprevStore: EffectStore | undefined,\n\tendEffect: () => void\n) {\n\tendEffect();\n\tcurrentStore = prevStore;\n}\n\n/**\n * A redux-like store whose store value is a positive 32bit integer (a\n * 'version').\n *\n * React subscribes to this store and gets a snapshot of the current 'version',\n * whenever the 'version' changes, we tell React it's time to update the\n * component (call 'onStoreChange').\n *\n * How we achieve this is by creating a binding with an 'effect', when the\n * `effect._callback' is called, we update our store version and tell React to\n * re-render the component ([1] We don't really care when/how React does it).\n *\n * [1]\n * @see https://react.dev/reference/react/useSyncExternalStore\n * @see\n * https://github.com/reactjs/rfcs/blob/main/text/0214-use-sync-external-store.md\n *\n * @param _usage An enum defining how this hook is used and whether it is\n * invoked in a component's body or hook body. See the comment on\n * `EffectStoreUsage` for more details.\n */\nfunction createEffectStore(\n\t_usage: EffectStoreUsage,\n\tcomponentName?: string\n): EffectStore {\n\tlet effectInstance!: Effect;\n\tlet endEffect: (() => void) | undefined;\n\tlet version = 0;\n\tlet onChangeNotifyReact: (() => void) | undefined;\n\n\tlet unsubscribe = effect(\n\t\tfunction (this: Effect) {\n\t\t\teffectInstance = this;\n\t\t},\n\t\t{ name: componentName || \"Component\" }\n\t);\n\teffectInstance._callback = function () {\n\t\tversion = (version + 1) | 0;\n\t\tif (DEVTOOLS_ENABLED) {\n\t\t\teffectInstance._debugCallback?.call(effectInstance);\n\t\t}\n\t\tif (onChangeNotifyReact) onChangeNotifyReact();\n\t};\n\n\treturn {\n\t\t_usage,\n\t\teffect: effectInstance,\n\t\tsubscribe(onStoreChange) {\n\t\t\tonChangeNotifyReact = onStoreChange;\n\n\t\t\treturn function () {\n\t\t\t\t/**\n\t\t\t\t * Rotate to next version when unsubscribing to ensure that components are re-run\n\t\t\t\t * when subscribing again.\n\t\t\t\t *\n\t\t\t\t * In StrictMode, 'memo'-ed components seem to keep a stale snapshot version, so\n\t\t\t\t * don't re-run after subscribing again if the version is the same as last time.\n\t\t\t\t *\n\t\t\t\t * Because we unsubscribe from the effect, the version may not change. We simply\n\t\t\t\t * set a new initial version in case of stale snapshots here.\n\t\t\t\t */\n\t\t\t\tversion = (version + 1) | 0;\n\t\t\t\tonChangeNotifyReact = undefined;\n\t\t\t\tunsubscribe();\n\t\t\t};\n\t\t},\n\t\tgetSnapshot() {\n\t\t\treturn version;\n\t\t},\n\t\t_start() {\n\t\t\t// In general, we want to support two kinds of usages of useSignals:\n\t\t\t//\n\t\t\t// A) Managed: calling useSignals in a component or hook body wrapped in a\n\t\t\t//    try/finally (like what the react-transform plugin does)\n\t\t\t//\n\t\t\t// B) Unmanaged: Calling useSignals directly without wrapping in a\n\t\t\t//    try/finally\n\t\t\t//\n\t\t\t// For managed, we finish the effect in the finally block of the component\n\t\t\t// or hook body. For unmanaged, we finish the effect in the next\n\t\t\t// useSignals call or after a microtask.\n\t\t\t//\n\t\t\t// There are different tradeoffs which each approach. With managed, using\n\t\t\t// a try/finally ensures that only signals used in the component or hook\n\t\t\t// body are tracked. However, signals accessed in render props are missed\n\t\t\t// because the render prop is invoked in another component that may or may\n\t\t\t// not realize it is rendering signals accessed in the render prop it is\n\t\t\t// given.\n\t\t\t//\n\t\t\t// The other approach is \"unmanaged\": to call useSignals directly without\n\t\t\t// wrapping in a try/finally. This approach is easier to manually write in\n\t\t\t// situations where a build step isn't available but does open up the\n\t\t\t// possibility of catching signals accessed in other code before the\n\t\t\t// effect is closed (e.g. in a layout effect). Most situations where this\n\t\t\t// could happen are generally consider bad patterns or bugs. For example,\n\t\t\t// using a signal in a component and not having a call to `useSignals`\n\t\t\t// would be an bug. Or using a signal in `useLayoutEffect` is generally\n\t\t\t// not recommended since that layout effect won't update when the signals'\n\t\t\t// value change.\n\t\t\t//\n\t\t\t// To support both approaches, we need to track how each invocation of\n\t\t\t// useSignals is used, so we can properly transition between different\n\t\t\t// kinds of usages.\n\t\t\t//\n\t\t\t// The following table shows the different scenarios and how we should\n\t\t\t// handle them.\n\t\t\t//\n\t\t\t// Key:\n\t\t\t// 0 = UNMANAGED\n\t\t\t// 1 = MANAGED_COMPONENT\n\t\t\t// 2 = MANAGED_HOOK\n\t\t\t//\n\t\t\t// Pattern:\n\t\t\t// prev store usage -> this store usage: action to take\n\t\t\t//\n\t\t\t// - 0 -> 0: finish previous effect (unknown to unknown)\n\t\t\t//\n\t\t\t//   We don't know how the previous effect was used, so we need to finish\n\t\t\t//   it before starting the next effect.\n\t\t\t//\n\t\t\t// - 0 -> 1: finish previous effect\n\t\t\t//\n\t\t\t//   Assume previous invocation was another component or hook from another\n\t\t\t//   component. Nested component renders (renderToStaticMarkup within a\n\t\t\t//   component's render) won't be supported with bare useSignals calls.\n\t\t\t//\n\t\t\t// - 0 -> 2: capture & restore\n\t\t\t//\n\t\t\t//   Previous invocation could be a component or a hook. Either way,\n\t\t\t//   restore it after our invocation so that it can continue to capture\n\t\t\t//   any signals after we exit.\n\t\t\t//\n\t\t\t// - 1 -> 0: Do nothing. Signals already captured by current effect store\n\t\t\t// - 1 -> 1: capture & restore (e.g. component calls renderToStaticMarkup)\n\t\t\t// - 1 -> 2: capture & restore (e.g. hook)\n\t\t\t//\n\t\t\t// - 2 -> 0: Do nothing. Signals already captured by current effect store\n\t\t\t// - 2 -> 1: capture & restore (e.g. hook calls renderToStaticMarkup)\n\t\t\t// - 2 -> 2: capture & restore (e.g. nested hook calls)\n\n\t\t\tif (currentStore == undefined) {\n\t\t\t\tendEffect = startComponentEffect(undefined, this);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst prevUsage = currentStore._usage;\n\t\t\tconst thisUsage = this._usage;\n\n\t\t\tif (\n\t\t\t\t(prevUsage == UNMANAGED && thisUsage == UNMANAGED) || // 0 -> 0\n\t\t\t\t(prevUsage == UNMANAGED && thisUsage == MANAGED_COMPONENT) // 0 -> 1\n\t\t\t) {\n\t\t\t\t// finish previous effect\n\t\t\t\tcurrentStore.f();\n\t\t\t\tendEffect = startComponentEffect(undefined, this);\n\t\t\t} else if (\n\t\t\t\t(prevUsage == MANAGED_COMPONENT && thisUsage == UNMANAGED) || // 1 -> 0\n\t\t\t\t(prevUsage == MANAGED_HOOK && thisUsage == UNMANAGED) // 2 -> 0\n\t\t\t) {\n\t\t\t\t// Do nothing since it'll be captured by current effect store\n\t\t\t} else {\n\t\t\t\t// nested scenarios, so capture and restore the previous effect store\n\t\t\t\tendEffect = startComponentEffect(currentStore, this);\n\t\t\t}\n\t\t},\n\t\tf() {\n\t\t\tconst end = endEffect;\n\t\t\tendEffect = undefined;\n\t\t\tend?.();\n\t\t},\n\t\t[symDispose]() {\n\t\t\tthis.f();\n\t\t},\n\t};\n}\n\nconst noop = () => {};\n\nfunction createEmptyEffectStore(): EffectStore {\n\treturn {\n\t\t_usage: UNMANAGED,\n\t\teffect: {\n\t\t\t_sources: undefined,\n\t\t\t_callback() {},\n\t\t\t_start() {\n\t\t\t\treturn /* endEffect */ noop;\n\t\t\t},\n\t\t\t_dispose() {},\n\t\t},\n\t\tsubscribe() {\n\t\t\treturn /* unsubscribe */ noop;\n\t\t},\n\t\tgetSnapshot() {\n\t\t\treturn 0;\n\t\t},\n\t\t_start() {},\n\t\tf() {},\n\t\t[symDispose]() {},\n\t};\n}\n\nconst emptyEffectStore = createEmptyEffectStore();\n\nconst _queueMicroTask = Promise.prototype.then.bind(Promise.resolve());\n\nlet finalCleanup: Promise<void> | undefined;\nexport function ensureFinalCleanup() {\n\tif (!finalCleanup) {\n\t\tfinalCleanup = _queueMicroTask(cleanupTrailingStore);\n\t}\n}\nfunction cleanupTrailingStore() {\n\tfinalCleanup = undefined;\n\tcurrentStore?.f();\n}\n\nconst useIsomorphicLayoutEffect =\n\ttypeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n\n/**\n * Custom hook to create the effect to track signals used during render and\n * subscribe to changes to rerender the component when the signals change.\n */\nexport function _useSignalsImplementation(\n\t_usage: EffectStoreUsage = UNMANAGED,\n\tcomponentName?: string\n): EffectStore {\n\tensureFinalCleanup();\n\n\tconst storeRef = useRef<EffectStore>();\n\tif (storeRef.current == null) {\n\t\tif (typeof window === \"undefined\") {\n\t\t\tstoreRef.current = emptyEffectStore;\n\t\t} else {\n\t\t\tstoreRef.current = createEffectStore(_usage, componentName);\n\t\t}\n\t}\n\n\tconst store = storeRef.current;\n\tuseSyncExternalStore(store.subscribe, store.getSnapshot, store.getSnapshot);\n\tstore._start();\n\t// note: _usage is a constant here, so conditional is okay\n\tif (_usage === UNMANAGED) useIsomorphicLayoutEffect(cleanupTrailingStore);\n\n\treturn store;\n}\n\n/**\n * A wrapper component that renders a Signal's value directly as a Text node or JSX.\n */\nfunction SignalValue({ data }: { data: Signal }) {\n\tconst store = _useSignalsImplementation(1);\n\ttry {\n\t\treturn data.value;\n\t} finally {\n\t\tstore.f();\n\t}\n}\n\n// Decorate Signals so React renders them as <SignalValue> components.\nObject.defineProperties(Signal.prototype, {\n\t$$typeof: { configurable: true, value: ReactElemType },\n\ttype: { configurable: true, value: SignalValue },\n\tprops: {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn { data: this };\n\t\t},\n\t},\n\tref: { configurable: true, value: null },\n});\n\nexport function useSignals(\n\tusage?: EffectStoreUsage,\n\tcomponentName?: string\n): EffectStore {\n\treturn _useSignalsImplementation(usage, componentName);\n}\n\nexport function useSignal<T>(value: T, options?: SignalOptions<T>): Signal<T>;\nexport function useSignal<T = undefined>(): Signal<T | undefined>;\nexport function useSignal<T>(value?: T, options?: SignalOptions<T>) {\n\treturn useMemo(\n\t\t() => signal<T | undefined>(value, options as SignalOptions),\n\t\tEmpty\n\t);\n}\n\nexport function useComputed<T>(\n\tcompute: () => T,\n\toptions?: SignalOptions<T>\n): ReadonlySignal<T> {\n\tconst $compute = useRef(compute);\n\t$compute.current = compute;\n\treturn useMemo(() => computed<T>(() => $compute.current(), options), Empty);\n}\n\nexport function useSignalEffect(\n\tcb: () => void | (() => void),\n\toptions?: EffectOptions\n) {\n\tconst callback = useRef(cb);\n\tcallback.current = cb;\n\n\tuseEffect(() => {\n\t\treturn effect(function (this: Effect) {\n\t\t\treturn callback.current();\n\t\t}, options);\n\t}, Empty);\n}\n\ndeclare global {\n\tinterface Window {\n\t\t__PREACT_SIGNALS_DEVTOOLS__: SignalsDevToolsAPI;\n\t}\n}\n\n/** See comment in packages/core/src/index.ts on the same interface for an explanation */\ninterface InternalModelConstructor<TModel, TArgs extends any[]>\n\textends ModelConstructor<TModel, TArgs> {\n\t(...args: TArgs): Model<TModel>;\n}\n\nexport function useModel<TModel>(\n\tfactory: ModelConstructor<TModel, []> | (() => Model<TModel>)\n): Model<TModel> {\n\ttype InternalFactory =\n\t\t| InternalModelConstructor<TModel, []>\n\t\t| (() => Model<TModel>);\n\n\tconst [inst] = useState(() => (factory as InternalFactory)());\n\tuseEffect(() => inst[Symbol.dispose], [inst]);\n\treturn inst;\n}\n"],"names":["Signal","signal","computed","effect","version","useRef","useMemo","useEffect","useState","useLayoutEffect","useSyncExternalStore","major","reactVersion","split","map","Number","Empty","ReactElemType","Symbol","DEVTOOLS_ENABLED","window","__PREACT_SIGNALS_DEVTOOLS__","wrapJsx","jsx","type","props","i","v","value","call","apply","concat","slice","arguments","currentStore","symDispose","dispose","startComponentEffect","prevStore","nextStore","endEffect","_start","finishComponentEffect","bind","_ref2","finalCleanup","noop","emptyEffectStore","_usage","_sources","undefined","_callback","_dispose","subscribe","getSnapshot","f","_queueMicroTask","Promise","prototype","then","resolve","ensureFinalCleanup","cleanupTrailingStore","_currentStore","useIsomorphicLayoutEffect","_useSignalsImplementation","componentName","storeRef","current","_ref","effectInstance","onChangeNotifyReact","unsubscribe","this","name","_effectInstance$_debu","_debugCallback","onStoreChange","prevUsage","thisUsage","end","createEffectStore","store","Object","defineProperties","$$typeof","configurable","_ref3","data","get","ref","useSignals","usage","useSignal","options","useComputed","compute","$compute","useSignalEffect","cb","callback","useModel","factory","inst"],"mappings":"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"}},
    {"offset": {"line": 754, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Documents/react-project/timesheet/node_modules/@preact/signals-react/dist/signals.module.js","sources":[],"sourcesContent":[],"names":[],"mappings":""}}]
}