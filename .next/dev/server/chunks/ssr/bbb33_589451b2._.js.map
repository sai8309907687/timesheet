{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/saireddy/Documents/react-project/timesheet/node_modules/next/node_modules/%40swc/helpers/cjs/_interop_require_wildcard.cjs"],"sourcesContent":["\"use strict\";\n\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) return obj;\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") return { default: obj };\n\n    var cache = _getRequireWildcardCache(nodeInterop);\n\n    if (cache && cache.has(obj)) return cache.get(obj);\n\n    var newObj = { __proto__: null };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n    for (var key in obj) {\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);\n            else newObj[key] = obj[key];\n        }\n    }\n\n    newObj.default = obj;\n\n    if (cache) cache.set(obj, newObj);\n\n    return newObj;\n}\nexports._ = _interop_require_wildcard;\n"],"names":[],"mappings":"AAEA,SAAS,yBAAyB,WAAW;IACzC,IAAI,OAAO,YAAY,YAAY,OAAO;IAE1C,IAAI,oBAAoB,IAAI;IAC5B,IAAI,mBAAmB,IAAI;IAE3B,OAAO,CAAC,2BAA2B,SAAS,WAAW;QACnD,OAAO,cAAc,mBAAmB;IAC5C,CAAC,EAAE;AACP;AACA,SAAS,0BAA0B,GAAG,EAAE,WAAW;IAC/C,IAAI,CAAC,eAAe,OAAO,IAAI,UAAU,EAAE,OAAO;IAClD,IAAI,QAAQ,QAAQ,OAAO,QAAQ,YAAY,OAAO,QAAQ,YAAY,OAAO;QAAE,SAAS;IAAI;IAEhG,IAAI,QAAQ,yBAAyB;IAErC,IAAI,SAAS,MAAM,GAAG,CAAC,MAAM,OAAO,MAAM,GAAG,CAAC;IAE9C,IAAI,SAAS;QAAE,WAAW;IAAK;IAC/B,IAAI,wBAAwB,OAAO,cAAc,IAAI,OAAO,wBAAwB;IAEpF,IAAK,IAAI,OAAO,IAAK;QACjB,IAAI,QAAQ,aAAa,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,MAAM;YACrE,IAAI,OAAO,wBAAwB,OAAO,wBAAwB,CAAC,KAAK,OAAO;YAC/E,IAAI,QAAQ,CAAC,KAAK,GAAG,IAAI,KAAK,GAAG,GAAG,OAAO,cAAc,CAAC,QAAQ,KAAK;iBAClE,MAAM,CAAC,IAAI,GAAG,GAAG,CAAC,IAAI;QAC/B;IACJ;IAEA,OAAO,OAAO,GAAG;IAEjB,IAAI,OAAO,MAAM,GAAG,CAAC,KAAK;IAE1B,OAAO;AACX;AACA,QAAQ,CAAC,GAAG","ignoreList":[0]}},
    {"offset": {"line": 39, "column": 0}, "map": {"version":3,"sources":["file:///Users/saireddy/Documents/react-project/timesheet/node_modules/next/node_modules/%40swc/helpers/cjs/_interop_require_default.cjs"],"sourcesContent":["\"use strict\";\n\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : { default: obj };\n}\nexports._ = _interop_require_default;\n"],"names":[],"mappings":"AAEA,SAAS,yBAAyB,GAAG;IACjC,OAAO,OAAO,IAAI,UAAU,GAAG,MAAM;QAAE,SAAS;IAAI;AACxD;AACA,QAAQ,CAAC,GAAG","ignoreList":[0]}},
    {"offset": {"line": 49, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Documents/react-project/timesheet/node_modules/@preact/signals-core/dist/signals-core.mjs","sources":["file:///Users/saireddy/Documents/react-project/timesheet/node_modules/%40preact/signals-core/src/index.ts"],"sourcesContent":["// An named symbol/brand for detecting Signal instances even when they weren't\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for(\"preact-signals\");\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n\t// A source whose value the target depends on.\n\t_source: Signal;\n\t_prevSource?: Node;\n\t_nextSource?: Node;\n\n\t// A target that depends on the source and should be notified when the source changes.\n\t_target: Computed | Effect;\n\t_prevTarget?: Node;\n\t_nextTarget?: Node;\n\n\t// The version number of the source that target has last seen. We use version numbers\n\t// instead of storing the source value, because source values can take arbitrary amount\n\t// of memory, and computeds could hang on to them forever because they're lazily evaluated.\n\t// Use the special value -1 to mark potentially unused but recyclable nodes.\n\t_version: number;\n\n\t// Used to remember & roll back the source's previous `._node` value when entering &\n\t// exiting a new evaluation context.\n\t_rollbackNode?: Node;\n};\n\nfunction startBatch() {\n\tbatchDepth++;\n}\n\nfunction endBatch() {\n\tif (batchDepth > 1) {\n\t\tbatchDepth--;\n\t\treturn;\n\t}\n\n\tlet error: unknown;\n\tlet hasError = false;\n\n\twhile (batchedEffect !== undefined) {\n\t\tlet effect: Effect | undefined = batchedEffect;\n\t\tbatchedEffect = undefined;\n\n\t\tbatchIteration++;\n\n\t\twhile (effect !== undefined) {\n\t\t\tconst next: Effect | undefined = effect._nextBatchedEffect;\n\t\t\teffect._nextBatchedEffect = undefined;\n\t\t\teffect._flags &= ~NOTIFIED;\n\n\t\t\tif (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n\t\t\t\ttry {\n\t\t\t\t\teffect._callback();\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!hasError) {\n\t\t\t\t\t\terror = err;\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\teffect = next;\n\t\t}\n\t}\n\tbatchIteration = 0;\n\tbatchDepth--;\n\n\tif (hasError) {\n\t\tthrow error;\n\t}\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n\tif (batchDepth > 0) {\n\t\treturn fn();\n\t}\n\t/*@__INLINE__**/ startBatch();\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tendBatch();\n\t}\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tevalContext = prevContext;\n\t}\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n\tif (evalContext === undefined) {\n\t\treturn undefined;\n\t}\n\n\tlet node = signal._node;\n\tif (node === undefined || node._target !== evalContext) {\n\t\t/**\n\t\t * `signal` is a new dependency. Create a new dependency node, and set it\n\t\t * as the tail of the current context's dependency list. e.g:\n\t\t *\n\t\t * { A <-> B       }\n\t\t *         ↑     ↑\n\t\t *        tail  node (new)\n\t\t *               ↓\n\t\t * { A <-> B <-> C }\n\t\t *               ↑\n\t\t *              tail (evalContext._sources)\n\t\t */\n\t\tnode = {\n\t\t\t_version: 0,\n\t\t\t_source: signal,\n\t\t\t_prevSource: evalContext._sources,\n\t\t\t_nextSource: undefined,\n\t\t\t_target: evalContext,\n\t\t\t_prevTarget: undefined,\n\t\t\t_nextTarget: undefined,\n\t\t\t_rollbackNode: node,\n\t\t};\n\n\t\tif (evalContext._sources !== undefined) {\n\t\t\tevalContext._sources._nextSource = node;\n\t\t}\n\t\tevalContext._sources = node;\n\t\tsignal._node = node;\n\n\t\t// Subscribe to change notifications from this dependency if we're in an effect\n\t\t// OR evaluating a computed signal that in turn has subscribers.\n\t\tif (evalContext._flags & TRACKING) {\n\t\t\tsignal._subscribe(node);\n\t\t}\n\t\treturn node;\n\t} else if (node._version === -1) {\n\t\t// `signal` is an existing dependency from a previous evaluation. Reuse it.\n\t\tnode._version = 0;\n\n\t\t/**\n\t\t * If `node` is not already the current tail of the dependency list (i.e.\n\t\t * there is a next node in the list), then make the `node` the new tail. e.g:\n\t\t *\n\t\t * { A <-> B <-> C <-> D }\n\t\t *         ↑           ↑\n\t\t *        node   ┌─── tail (evalContext._sources)\n\t\t *         └─────│─────┐\n\t\t *               ↓     ↓\n\t\t * { A <-> C <-> D <-> B }\n\t\t *                     ↑\n\t\t *                    tail (evalContext._sources)\n\t\t */\n\t\tif (node._nextSource !== undefined) {\n\t\t\tnode._nextSource._prevSource = node._prevSource;\n\n\t\t\tif (node._prevSource !== undefined) {\n\t\t\t\tnode._prevSource._nextSource = node._nextSource;\n\t\t\t}\n\n\t\t\tnode._prevSource = evalContext._sources;\n\t\t\tnode._nextSource = undefined;\n\n\t\t\tevalContext._sources!._nextSource = node;\n\t\t\tevalContext._sources = node;\n\t\t}\n\n\t\t// We can assume that the currently evaluated effect / computed signal is already\n\t\t// subscribed to change notifications from `signal` if needed.\n\t\treturn node;\n\t}\n\treturn undefined;\n}\n\n//#region Signal\n\n/**\n * The base class for plain and computed signals.\n */\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style prototypes.\n// This enables better control of the transpiled output size.\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\ndeclare class Signal<T = any> {\n\t/** @internal */\n\t_value: unknown;\n\n\t/**\n\t * @internal\n\t * Version numbers should always be >= 0, because the special value -1 is used\n\t * by Nodes to signify potentially unused but recyclable nodes.\n\t */\n\t_version: number;\n\n\t/** @internal */\n\t_node?: Node;\n\n\t/** @internal */\n\t_targets?: Node;\n\n\tconstructor(value?: T, options?: SignalOptions<T>);\n\n\t/** @internal */\n\t_refresh(): boolean;\n\n\t/** @internal */\n\t_subscribe(node: Node): void;\n\n\t/** @internal */\n\t_unsubscribe(node: Node): void;\n\n\t/** @internal */\n\t_watched?(this: Signal<T>): void;\n\n\t/** @internal */\n\t_unwatched?(this: Signal<T>): void;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\n\tname?: string;\n\n\tvalueOf(): T;\n\n\ttoString(): string;\n\n\ttoJSON(): T;\n\n\tpeek(): T;\n\n\tbrand: typeof BRAND_SYMBOL;\n\n\tget value(): T;\n\tset value(value: T);\n}\n\nexport interface SignalOptions<T = any> {\n\twatched?: (this: Signal<T>) => void;\n\tunwatched?: (this: Signal<T>) => void;\n\tname?: string;\n}\n\n/** @internal */\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style prototypes.\n// This enables better control of the transpiled output size.\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\nfunction Signal(this: Signal, value?: unknown, options?: SignalOptions) {\n\tthis._value = value;\n\tthis._version = 0;\n\tthis._node = undefined;\n\tthis._targets = undefined;\n\tthis._watched = options?.watched;\n\tthis._unwatched = options?.unwatched;\n\tthis.name = options?.name;\n}\n\nSignal.prototype.brand = BRAND_SYMBOL;\n\nSignal.prototype._refresh = function () {\n\treturn true;\n};\n\nSignal.prototype._subscribe = function (node) {\n\tconst targets = this._targets;\n\tif (targets !== node && node._prevTarget === undefined) {\n\t\tnode._nextTarget = targets;\n\t\tthis._targets = node;\n\n\t\tif (targets !== undefined) {\n\t\t\ttargets._prevTarget = node;\n\t\t} else {\n\t\t\tuntracked(() => {\n\t\t\t\tthis._watched?.call(this);\n\t\t\t});\n\t\t}\n\t}\n};\n\nSignal.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the signal has any subscribers to begin with.\n\tif (this._targets !== undefined) {\n\t\tconst prev = node._prevTarget;\n\t\tconst next = node._nextTarget;\n\t\tif (prev !== undefined) {\n\t\t\tprev._nextTarget = next;\n\t\t\tnode._prevTarget = undefined;\n\t\t}\n\n\t\tif (next !== undefined) {\n\t\t\tnext._prevTarget = prev;\n\t\t\tnode._nextTarget = undefined;\n\t\t}\n\n\t\tif (node === this._targets) {\n\t\t\tthis._targets = next;\n\t\t\tif (next === undefined) {\n\t\t\t\tuntracked(() => {\n\t\t\t\t\tthis._unwatched?.call(this);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n};\n\nSignal.prototype.subscribe = function (fn) {\n\treturn effect(\n\t\t() => {\n\t\t\tconst value = this.value;\n\t\t\tconst prevContext = evalContext;\n\t\t\tevalContext = undefined;\n\t\t\ttry {\n\t\t\t\tfn(value);\n\t\t\t} finally {\n\t\t\t\tevalContext = prevContext;\n\t\t\t}\n\t\t},\n\t\t{ name: \"sub\" }\n\t);\n};\n\nSignal.prototype.valueOf = function () {\n\treturn this.value;\n};\n\nSignal.prototype.toString = function () {\n\treturn this.value + \"\";\n};\n\nSignal.prototype.toJSON = function () {\n\treturn this.value;\n};\n\nSignal.prototype.peek = function () {\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\ttry {\n\t\treturn this.value;\n\t} finally {\n\t\tevalContext = prevContext;\n\t}\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n\tget(this: Signal) {\n\t\tconst node = addDependency(this);\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\treturn this._value;\n\t},\n\tset(this: Signal, value) {\n\t\tif (value !== this._value) {\n\t\t\tif (batchIteration > 100) {\n\t\t\t\tthrow new Error(\"Cycle detected\");\n\t\t\t}\n\n\t\t\tthis._value = value;\n\t\t\tthis._version++;\n\t\t\tglobalVersion++;\n\n\t\t\t/**@__INLINE__*/ startBatch();\n\t\t\ttry {\n\t\t\t\tfor (\n\t\t\t\t\tlet node = this._targets;\n\t\t\t\t\tnode !== undefined;\n\t\t\t\t\tnode = node._nextTarget\n\t\t\t\t) {\n\t\t\t\t\tnode._target._notify();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tendBatch();\n\t\t\t}\n\t\t}\n\t},\n});\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T, options?: SignalOptions<T>): Signal<T>;\nexport function signal<T = undefined>(): Signal<T | undefined>;\nexport function signal<T>(value?: T, options?: SignalOptions<T>): Signal<T> {\n\treturn new Signal(value, options);\n}\n\n//#endregion Signal\n\n//#region Computed\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n\t// Check the dependencies for changed values. The dependency list is already\n\t// in order of use. Therefore if multiple dependencies have changed values, only\n\t// the first used dependency is re-evaluated at this point.\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tif (\n\t\t\t// If the dependency has definitely been updated since its version number\n\t\t\t// was observed, then we need to recompute. This first check is not strictly\n\t\t\t// necessary for correctness, but allows us to skip the refresh call if the\n\t\t\t// dependency has already been updated.\n\t\t\tnode._source._version !== node._version ||\n\t\t\t// Refresh the dependency. If there's something blocking the refresh (e.g. a\n\t\t\t// dependency cycle), then we need to recompute.\n\t\t\t!node._source._refresh() ||\n\t\t\t// If the dependency got a new version after the refresh, then we need to recompute.\n\t\t\tnode._source._version !== node._version\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t// If none of the dependencies have changed values since last recompute then\n\t// there's no need to recompute.\n\treturn false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n\t/**\n\t * 1. Mark all current sources as re-usable nodes (version: -1)\n\t * 2. Set a rollback node if the current node is being used in a different context\n\t * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n\t *\n\t *    { undefined <- A <-> B <-> C -> undefined }\n\t *                   ↑           ↑\n\t *                   │           └──────┐\n\t * target._sources = A; (node is head)  │\n\t *                   ↓                  │\n\t * target._sources = C; (node is tail) ─┘\n\t */\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tconst rollbackNode = node._source._node;\n\t\tif (rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = rollbackNode;\n\t\t}\n\t\tnode._source._node = node;\n\t\tnode._version = -1;\n\n\t\tif (node._nextSource === undefined) {\n\t\t\ttarget._sources = node;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n\tlet node = target._sources;\n\tlet head: Node | undefined = undefined;\n\n\t/**\n\t * At this point 'target._sources' points to the tail of the doubly-linked list.\n\t * It contains all existing sources + new sources in order of use.\n\t * Iterate backwards until we find the head node while dropping old dependencies.\n\t */\n\twhile (node !== undefined) {\n\t\tconst prev = node._prevSource;\n\n\t\t/**\n\t\t * The node was not re-used, unsubscribe from its change notifications and remove itself\n\t\t * from the doubly-linked list. e.g:\n\t\t *\n\t\t * { A <-> B <-> C }\n\t\t *         ↓\n\t\t *    { A <-> C }\n\t\t */\n\t\tif (node._version === -1) {\n\t\t\tnode._source._unsubscribe(node);\n\n\t\t\tif (prev !== undefined) {\n\t\t\t\tprev._nextSource = node._nextSource;\n\t\t\t}\n\t\t\tif (node._nextSource !== undefined) {\n\t\t\t\tnode._nextSource._prevSource = prev;\n\t\t\t}\n\t\t} else {\n\t\t\t/**\n\t\t\t * The new head is the last node seen which wasn't removed/unsubscribed\n\t\t\t * from the doubly-linked list. e.g:\n\t\t\t *\n\t\t\t * { A <-> B <-> C }\n\t\t\t *   ↑     ↑     ↑\n\t\t\t *   │     │     └ head = node\n\t\t\t *   │     └ head = node\n\t\t\t *   └ head = node\n\t\t\t */\n\t\t\thead = node;\n\t\t}\n\n\t\tnode._source._node = node._rollbackNode;\n\t\tif (node._rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = undefined;\n\t\t}\n\n\t\tnode = prev;\n\t}\n\n\ttarget._sources = head;\n}\n\n/**\n * The base class for computed signals.\n */\ndeclare class Computed<T = any> extends Signal<T> {\n\t_fn: () => T;\n\t_sources?: Node;\n\t_globalVersion: number;\n\t_flags: number;\n\n\tconstructor(fn: () => T, options?: SignalOptions<T>);\n\n\t_notify(): void;\n\tget value(): T;\n}\n\n/** @internal */\nfunction Computed(this: Computed, fn: () => unknown, options?: SignalOptions) {\n\tSignal.call(this, undefined);\n\n\tthis._fn = fn;\n\tthis._sources = undefined;\n\tthis._globalVersion = globalVersion - 1;\n\tthis._flags = OUTDATED;\n\tthis._watched = options?.watched;\n\tthis._unwatched = options?.unwatched;\n\tthis.name = options?.name;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n\tthis._flags &= ~NOTIFIED;\n\n\tif (this._flags & RUNNING) {\n\t\treturn false;\n\t}\n\n\t// If this computed signal has subscribed to updates from its dependencies\n\t// (TRACKING flag set) and none of them have notified about changes (OUTDATED\n\t// flag not set), then the computed value can't have changed.\n\tif ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n\t\treturn true;\n\t}\n\tthis._flags &= ~OUTDATED;\n\n\tif (this._globalVersion === globalVersion) {\n\t\treturn true;\n\t}\n\tthis._globalVersion = globalVersion;\n\n\t// Mark this computed signal running before checking the dependencies for value\n\t// changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n\tthis._flags |= RUNNING;\n\tif (this._version > 0 && !needsToRecompute(this)) {\n\t\tthis._flags &= ~RUNNING;\n\t\treturn true;\n\t}\n\n\tconst prevContext = evalContext;\n\ttry {\n\t\tprepareSources(this);\n\t\tevalContext = this;\n\t\tconst value = this._fn();\n\t\tif (\n\t\t\tthis._flags & HAS_ERROR ||\n\t\t\tthis._value !== value ||\n\t\t\tthis._version === 0\n\t\t) {\n\t\t\tthis._value = value;\n\t\t\tthis._flags &= ~HAS_ERROR;\n\t\t\tthis._version++;\n\t\t}\n\t} catch (err) {\n\t\tthis._value = err;\n\t\tthis._flags |= HAS_ERROR;\n\t\tthis._version++;\n\t}\n\tevalContext = prevContext;\n\tcleanupSources(this);\n\tthis._flags &= ~RUNNING;\n\treturn true;\n};\n\nComputed.prototype._subscribe = function (node) {\n\tif (this._targets === undefined) {\n\t\tthis._flags |= OUTDATED | TRACKING;\n\n\t\t// A computed signal subscribes lazily to its dependencies when it\n\t\t// gets its first subscriber.\n\t\tfor (\n\t\t\tlet node = this._sources;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextSource\n\t\t) {\n\t\t\tnode._source._subscribe(node);\n\t\t}\n\t}\n\tSignal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the computed signal has any subscribers.\n\tif (this._targets !== undefined) {\n\t\tSignal.prototype._unsubscribe.call(this, node);\n\n\t\t// Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n\t\t// This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n\t\tif (this._targets === undefined) {\n\t\t\tthis._flags &= ~TRACKING;\n\n\t\t\tfor (\n\t\t\t\tlet node = this._sources;\n\t\t\t\tnode !== undefined;\n\t\t\t\tnode = node._nextSource\n\t\t\t) {\n\t\t\t\tnode._source._unsubscribe(node);\n\t\t\t}\n\t\t}\n\t}\n};\n\nComputed.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= OUTDATED | NOTIFIED;\n\n\t\tfor (\n\t\t\tlet node = this._targets;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextTarget\n\t\t) {\n\t\t\tnode._target._notify();\n\t\t}\n\t}\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n\tget(this: Computed) {\n\t\tif (this._flags & RUNNING) {\n\t\t\tthrow new Error(\"Cycle detected\");\n\t\t}\n\t\tconst node = addDependency(this);\n\t\tthis._refresh();\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\tif (this._flags & HAS_ERROR) {\n\t\t\tthrow this._value;\n\t\t}\n\t\treturn this._value;\n\t},\n});\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n\treadonly value: T;\n\tpeek(): T;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\tvalueOf(): T;\n\ttoString(): string;\n\ttoJSON(): T;\n\tbrand: typeof BRAND_SYMBOL;\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(\n\tfn: () => T,\n\toptions?: SignalOptions<T>\n): ReadonlySignal<T> {\n\treturn new Computed(fn, options);\n}\n\n//#endregion Computed\n\n//#region Effect\n\nfunction cleanupEffect(effect: Effect) {\n\tconst cleanup = effect._cleanup;\n\teffect._cleanup = undefined;\n\n\tif (typeof cleanup === \"function\") {\n\t\t/*@__INLINE__**/ startBatch();\n\n\t\t// Run cleanup functions always outside of any context.\n\t\tconst prevContext = evalContext;\n\t\tevalContext = undefined;\n\t\ttry {\n\t\t\tcleanup();\n\t\t} catch (err) {\n\t\t\teffect._flags &= ~RUNNING;\n\t\t\teffect._flags |= DISPOSED;\n\t\t\tdisposeEffect(effect);\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tevalContext = prevContext;\n\t\t\tendBatch();\n\t\t}\n\t}\n}\n\nfunction disposeEffect(effect: Effect) {\n\tfor (\n\t\tlet node = effect._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tnode._source._unsubscribe(node);\n\t}\n\teffect._fn = undefined;\n\teffect._sources = undefined;\n\n\tcleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n\tif (evalContext !== this) {\n\t\tthrow new Error(\"Out-of-order effect\");\n\t}\n\tcleanupSources(this);\n\tevalContext = prevContext;\n\n\tthis._flags &= ~RUNNING;\n\tif (this._flags & DISPOSED) {\n\t\tdisposeEffect(this);\n\t}\n\tendBatch();\n}\n\ntype EffectFn =\n\t| ((this: { dispose: () => void }) => void | (() => void))\n\t| (() => void | (() => void));\n\n/**\n * The base class for reactive effects.\n */\ndeclare class Effect {\n\t_fn?: EffectFn;\n\t_cleanup?: () => void;\n\t_sources?: Node;\n\t_nextBatchedEffect?: Effect;\n\t_flags: number;\n\t_debugCallback?: () => void;\n\tname?: string;\n\n\tconstructor(fn: EffectFn, options?: EffectOptions);\n\n\t_callback(): void;\n\t_start(): () => void;\n\t_notify(): void;\n\t_dispose(): void;\n\tdispose(): void;\n}\n\nexport interface EffectOptions {\n\tname?: string;\n}\n\nlet capturedEffects: Effect[] | undefined;\n\n/** @internal */\nfunction Effect(this: Effect, fn: EffectFn, options?: EffectOptions) {\n\tthis._fn = fn;\n\tthis._cleanup = undefined;\n\tthis._sources = undefined;\n\tthis._nextBatchedEffect = undefined;\n\tthis._flags = TRACKING;\n\tthis.name = options?.name;\n\n\tif (capturedEffects) {\n\t\tcapturedEffects.push(this);\n\t}\n}\n\nEffect.prototype._callback = function () {\n\tconst finish = this._start();\n\ttry {\n\t\tif (this._flags & DISPOSED) return;\n\t\tif (this._fn === undefined) return;\n\n\t\tconst cleanup = this._fn();\n\t\tif (typeof cleanup === \"function\") {\n\t\t\tthis._cleanup = cleanup;\n\t\t}\n\t} finally {\n\t\tfinish();\n\t}\n};\n\nEffect.prototype._start = function () {\n\tif (this._flags & RUNNING) {\n\t\tthrow new Error(\"Cycle detected\");\n\t}\n\tthis._flags |= RUNNING;\n\tthis._flags &= ~DISPOSED;\n\tcleanupEffect(this);\n\tprepareSources(this);\n\n\t/*@__INLINE__**/ startBatch();\n\tconst prevContext = evalContext;\n\tevalContext = this;\n\treturn endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= NOTIFIED;\n\t\tthis._nextBatchedEffect = batchedEffect;\n\t\tbatchedEffect = this;\n\t}\n};\n\nEffect.prototype._dispose = function () {\n\tthis._flags |= DISPOSED;\n\n\tif (!(this._flags & RUNNING)) {\n\t\tdisposeEffect(this);\n\t}\n};\n\nEffect.prototype.dispose = function () {\n\tthis._dispose();\n};\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn, options?: EffectOptions): () => void {\n\tconst effect = new Effect(fn, options);\n\ttry {\n\t\teffect._callback();\n\t} catch (err) {\n\t\teffect._dispose();\n\t\tthrow err;\n\t}\n\t// Return a bound function instead of a wrapper like `() => effect._dispose()`,\n\t// because bound functions seem to be just as fast and take up a lot less memory.\n\tconst dispose = effect._dispose.bind(effect);\n\t(dispose as any)[Symbol.dispose] = dispose;\n\treturn dispose as any;\n}\n\n//#endregion Effect\n\n//#region Action\n\nfunction action<TArgs extends unknown[], TReturn>(\n\tfn: (...args: TArgs) => TReturn\n): (...args: TArgs) => TReturn {\n\treturn function actionWrapper(this: unknown, ...args: TArgs) {\n\t\treturn batch(() => untracked(() => fn.apply(this, args)));\n\t};\n}\n\n//#endregion Action\n\n//#region createModel\n\n/** Models should only contain signals, actions, and nested objects containing only signals and actions. */\ntype ValidateModel<TModel> = {\n\t[Key in keyof TModel]: TModel[Key] extends ReadonlySignal<unknown>\n\t\t? TModel[Key]\n\t\t: TModel[Key] extends (...args: any[]) => any\n\t\t\t? TModel[Key]\n\t\t\t: TModel[Key] extends object\n\t\t\t\t? ValidateModel<TModel[Key]>\n\t\t\t\t: `Property ${Key extends string ? `'${Key}' ` : \"\"}is not a Signal, Action, or an object that contains only Signals and Actions.`;\n};\n\nexport type Model<TModel> = ValidateModel<TModel> & Disposable;\n\nexport type ModelFactory<TModel, TFactoryArgs extends any[] = []> = (\n\t...args: TFactoryArgs\n) => ValidateModel<TModel>;\nexport type ModelConstructor<TModel, TFactoryArgs extends any[] = []> = new (\n\t...args: TFactoryArgs\n) => Model<TModel>;\n\n/**\n * The public types for ModelConstructor require using `new` to help\n * disambiguate the function passed into `createModel` and the returned\n * constructor function. It is easier to say that `createModel` accepts\n * a factory and returns a class, then to say it accepts a factory and\n * returns a factory. In other words, this example:\n *\n * ```ts\n * const PersonModel = createModel((name: string) => ({ ... }));\n * const person = new PersonModel(\"John\");\n * ```\n *\n * is easier to understand than this example:\n *\n * ```ts\n * const createPerson = createModel((name: string) => ({ ... }));\n * const person = createPerson(\"John\");\n * ```\n *\n * However, internally we implement `createModel` to return a function\n * that can be called without `new` for simplicity. To bridge the gap\n * between the public types and the internal implementation, we define\n * this internal interface that extends the public interface but also\n * allows calling without `new`.\n *\n * This pattern is used by the Preact & React adapters to make instantiating\n * a model or a function that returns a model easier.\n *\n * @internal\n */\ninterface InternalModelConstructor<TModel, TFactoryArgs extends any[]>\n\textends ModelConstructor<TModel, TFactoryArgs> {\n\t(...args: TFactoryArgs): Model<TModel>;\n}\n\nfunction startCapturingEffects(): () => Effect[] | undefined {\n\tlet prevCapturedEffects = capturedEffects;\n\tcapturedEffects = [];\n\n\treturn function stopCapturingEffects() {\n\t\tlet modelEffects = capturedEffects;\n\t\tif (capturedEffects && prevCapturedEffects) {\n\t\t\tprevCapturedEffects = prevCapturedEffects.concat(capturedEffects);\n\t\t}\n\n\t\tcapturedEffects = prevCapturedEffects;\n\n\t\treturn modelEffects;\n\t};\n}\n\nfunction createModel<TModel, TFactoryArgs extends any[] = []>(\n\tmodelFactory: ModelFactory<TModel, TFactoryArgs>\n): ModelConstructor<TModel, TFactoryArgs> {\n\treturn function SignalModel(...args: TFactoryArgs): Model<TModel> {\n\t\tlet modelEffects: Effect[] | undefined;\n\t\tlet model: Model<TModel>;\n\n\t\tconst stopCapturingEffects = startCapturingEffects();\n\t\ttry {\n\t\t\tmodel = modelFactory(...args) as Model<TModel>;\n\t\t} catch (err) {\n\t\t\t// Drop any captured effects on error. Errors from nested models will bubble\n\t\t\t// up here and recursively reset `capturedEffects` to `undefined` preventing\n\t\t\t// any captured effects from leaking\n\t\t\tcapturedEffects = undefined;\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tmodelEffects = stopCapturingEffects();\n\t\t}\n\n\t\tfor (const key in model) {\n\t\t\t// @ts-expect-error TypeScript can't infer that model[key] is a valid here\n\t\t\tif (typeof model[key] === \"function\") {\n\t\t\t\t// @ts-expect-error TypeScript can't infer that model[key] is a valid function\n\t\t\t\t// to pass to action here\n\t\t\t\tmodel[key] = action(model[key]);\n\t\t\t}\n\t\t}\n\n\t\tmodel[Symbol.dispose] = action(function disposeModel() {\n\t\t\tif (modelEffects) {\n\t\t\t\tfor (let i = 0; i < modelEffects.length; i++) {\n\t\t\t\t\tmodelEffects[i].dispose();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmodelEffects = undefined;\n\t\t});\n\n\t\treturn model;\n\t} as InternalModelConstructor<TModel, TFactoryArgs>;\n}\n\n//#endregion createModel\n\nexport {\n\tcomputed,\n\teffect,\n\tbatch,\n\tuntracked,\n\taction,\n\tcreateModel,\n\tSignal,\n\tReadonlySignal,\n\tEffect,\n\tComputed,\n};\n"],"names":["BRAND_SYMBOL","Symbol","for","endBatch","batchDepth","error","hasError","undefined","batchedEffect","effect","batchIteration","next","_nextBatchedEffect","_flags","needsToRecompute","_callback","err","batch","fn","evalContext","untracked","prevContext","capturedEffects","globalVersion","addDependency","signal","node","_node","_target","_version","_source","_prevSource","_sources","_nextSource","_prevTarget","_nextTarget","_rollbackNode","_subscribe","Signal","value","options","this","_value","_targets","_watched","watched","_unwatched","unwatched","name","prototype","brand","_refresh","targets","_this$_watched","call","_unsubscribe","prev","_this$_unwatched","subscribe","valueOf","toString","toJSON","peek","Object","defineProperty","get","set","Error","_notify","target","prepareSources","rollbackNode","cleanupSources","head","Computed","_fn","_globalVersion","OUTDATED","computed","cleanupEffect","cleanup","_cleanup","disposeEffect","endEffect","Effect","push","finish","_start","bind","_dispose","dispose","action","args","apply","createModel","modelFactory","modelEffects","model","stopCapturingEffects","prevCapturedEffects","concat","startCapturingEffects","key","i","length"],"mappings":"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"}},
    {"offset": {"line": 493, "column": 0}, "map": {"version":3,"sources":["file:///Users/saireddy/Documents/react-project/timesheet/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"],"sourcesContent":["/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    function useSyncExternalStore$2(subscribe, getSnapshot) {\n      didWarnOld18Alpha ||\n        void 0 === React.startTransition ||\n        ((didWarnOld18Alpha = !0),\n        console.error(\n          \"You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.\"\n        ));\n      var value = getSnapshot();\n      if (!didWarnUncachedGetSnapshot) {\n        var cachedValue = getSnapshot();\n        objectIs(value, cachedValue) ||\n          (console.error(\n            \"The result of getSnapshot should be cached to avoid an infinite loop\"\n          ),\n          (didWarnUncachedGetSnapshot = !0));\n      }\n      cachedValue = useState({\n        inst: { value: value, getSnapshot: getSnapshot }\n      });\n      var inst = cachedValue[0].inst,\n        forceUpdate = cachedValue[1];\n      useLayoutEffect(\n        function () {\n          inst.value = value;\n          inst.getSnapshot = getSnapshot;\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n        },\n        [subscribe, value, getSnapshot]\n      );\n      useEffect(\n        function () {\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          return subscribe(function () {\n            checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          });\n        },\n        [subscribe]\n      );\n      useDebugValue(value);\n      return value;\n    }\n    function checkIfSnapshotChanged(inst) {\n      var latestGetSnapshot = inst.getSnapshot;\n      inst = inst.value;\n      try {\n        var nextValue = latestGetSnapshot();\n        return !objectIs(inst, nextValue);\n      } catch (error) {\n        return !0;\n      }\n    }\n    function useSyncExternalStore$1(subscribe, getSnapshot) {\n      return getSnapshot();\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = require(\"react\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useState = React.useState,\n      useEffect = React.useEffect,\n      useLayoutEffect = React.useLayoutEffect,\n      useDebugValue = React.useDebugValue,\n      didWarnOld18Alpha = !1,\n      didWarnUncachedGetSnapshot = !1,\n      shim =\n        \"undefined\" === typeof window ||\n        \"undefined\" === typeof window.document ||\n        \"undefined\" === typeof window.document.createElement\n          ? useSyncExternalStore$1\n          : useSyncExternalStore$2;\n    exports.useSyncExternalStore =\n      void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n"],"names":[],"mappings":"AAAA;;;;;;;;CAQC,GAGD,oEACE,AAAC;IACC,SAAS,GAAG,CAAC,EAAE,CAAC;QACd,OAAO,AAAC,MAAM,KAAK,CAAC,MAAM,KAAK,IAAI,MAAM,IAAI,CAAC,KAAO,MAAM,KAAK,MAAM;IACxE;IACA,SAAS,uBAAuB,SAAS,EAAE,WAAW;QACpD,qBACE,KAAK,MAAM,MAAM,eAAe,IAChC,CAAC,AAAC,oBAAoB,CAAC,GACvB,QAAQ,KAAK,CACX,iMACD;QACH,IAAI,QAAQ;QACZ,IAAI,CAAC,4BAA4B;YAC/B,IAAI,cAAc;YAClB,SAAS,OAAO,gBACd,CAAC,QAAQ,KAAK,CACZ,yEAED,6BAA6B,CAAC,CAAE;QACrC;QACA,cAAc,SAAS;YACrB,MAAM;gBAAE,OAAO;gBAAO,aAAa;YAAY;QACjD;QACA,IAAI,OAAO,WAAW,CAAC,EAAE,CAAC,IAAI,EAC5B,cAAc,WAAW,CAAC,EAAE;QAC9B,gBACE;YACE,KAAK,KAAK,GAAG;YACb,KAAK,WAAW,GAAG;YACnB,uBAAuB,SAAS,YAAY;gBAAE,MAAM;YAAK;QAC3D,GACA;YAAC;YAAW;YAAO;SAAY;QAEjC,UACE;YACE,uBAAuB,SAAS,YAAY;gBAAE,MAAM;YAAK;YACzD,OAAO,UAAU;gBACf,uBAAuB,SAAS,YAAY;oBAAE,MAAM;gBAAK;YAC3D;QACF,GACA;YAAC;SAAU;QAEb,cAAc;QACd,OAAO;IACT;IACA,SAAS,uBAAuB,IAAI;QAClC,IAAI,oBAAoB,KAAK,WAAW;QACxC,OAAO,KAAK,KAAK;QACjB,IAAI;YACF,IAAI,YAAY;YAChB,OAAO,CAAC,SAAS,MAAM;QACzB,EAAE,OAAO,OAAO;YACd,OAAO,CAAC;QACV;IACF;IACA,SAAS,uBAAuB,SAAS,EAAE,WAAW;QACpD,OAAO;IACT;IACA,gBAAgB,OAAO,kCACrB,eACE,OAAO,+BAA+B,2BAA2B,IACnE,+BAA+B,2BAA2B,CAAC;IAC7D,IAAI,kLACF,WAAW,eAAe,OAAO,OAAO,EAAE,GAAG,OAAO,EAAE,GAAG,IACzD,WAAW,MAAM,QAAQ,EACzB,YAAY,MAAM,SAAS,EAC3B,kBAAkB,MAAM,eAAe,EACvC,gBAAgB,MAAM,aAAa,EACnC,oBAAoB,CAAC,GACrB,6BAA6B,CAAC,GAC9B,OACE,uCAGI,yBACA;IACR,QAAQ,oBAAoB,GAC1B,KAAK,MAAM,MAAM,oBAAoB,GAAG,MAAM,oBAAoB,GAAG;IACvE,gBAAgB,OAAO,kCACrB,eACE,OAAO,+BAA+B,0BAA0B,IAClE,+BAA+B,0BAA0B,CAAC;AAC9D","ignoreList":[0]}},
    {"offset": {"line": 567, "column": 0}, "map": {"version":3,"sources":["file:///Users/saireddy/Documents/react-project/timesheet/node_modules/use-sync-external-store/shim/index.js"],"sourcesContent":["'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n"],"names":[],"mappings":"AAEA;;KAEO;IACL,OAAO,OAAO;AAChB","ignoreList":[0]}},
    {"offset": {"line": 576, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Documents/react-project/timesheet/node_modules/@preact/signals-react/runtime/dist/runtime.mjs","sources":["file:///Users/saireddy/Documents/react-project/timesheet/node_modules/%40preact/signals-react/runtime/src/index.ts"],"sourcesContent":["import {\n\tsignal,\n\tcomputed,\n\teffect,\n\tSignal,\n\tReadonlySignal,\n\tSignalOptions,\n\tEffectOptions,\n\ttype Model,\n\ttype ModelConstructor,\n} from \"@preact/signals-core\";\nimport {\n\tuseState,\n\tuseRef,\n\tuseMemo,\n\tuseEffect,\n\tuseLayoutEffect,\n\tversion as reactVersion,\n} from \"react\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\nimport type { SignalsDevToolsAPI } from \"../../../debug/src/devtools\";\n\nconst [major] = reactVersion.split(\".\").map(Number);\nconst Empty = [] as const;\n// V19 https://github.com/facebook/react/blob/346c7d4c43a0717302d446da9e7423a8e28d8996/packages/shared/ReactSymbols.js#L15\n// V18 https://github.com/facebook/react/blob/346c7d4c43a0717302d446da9e7423a8e28d8996/packages/shared/ReactSymbols.js#L15\nconst ReactElemType = Symbol.for(\n\tmajor >= 19 ? \"react.transitional.element\" : \"react.element\"\n);\n\nconst DEVTOOLS_ENABLED =\n\ttypeof window !== \"undefined\" && !!window.__PREACT_SIGNALS_DEVTOOLS__;\n\nexport function wrapJsx<T>(jsx: T): T {\n\tif (typeof jsx !== \"function\") return jsx;\n\n\treturn function (type: any, props: any, ...rest: any[]) {\n\t\tif (typeof type === \"string\" && props) {\n\t\t\tfor (let i in props) {\n\t\t\t\tlet v = props[i];\n\t\t\t\tif (i !== \"children\" && v instanceof Signal) {\n\t\t\t\t\tprops[i] = v.value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jsx.call(jsx, type, props, ...rest);\n\t} as any as T;\n}\n\nconst symDispose: unique symbol =\n\t(Symbol as any).dispose || Symbol.for(\"Symbol.dispose\");\n\ninterface Effect {\n\t_sources: object | undefined;\n\t_debugCallback?: () => void;\n\t_start(): () => void;\n\t_callback(): void;\n\t_dispose(): void;\n}\n\n/**\n * Use this flag to represent a bare `useSignals` call that doesn't manually\n * close its effect store and relies on auto-closing when the next useSignals is\n * called or after a microtask\n */\nconst UNMANAGED = 0;\n/**\n * Use this flag to represent a `useSignals` call that is manually closed by a\n * try/finally block in a component's render method. This is the default usage\n * that the react-transform plugin uses.\n */\nconst MANAGED_COMPONENT = 1;\n/**\n * Use this flag to represent a `useSignals` call that is manually closed by a\n * try/finally block in a hook body. This is the default usage that the\n * react-transform plugin uses.\n */\nconst MANAGED_HOOK = 2;\n\n/**\n * An enum defining how this store is used. See the documentation for each enum\n * member for more details.\n * @see {@link UNMANAGED}\n * @see {@link MANAGED_COMPONENT}\n * @see {@link MANAGED_HOOK}\n */\ntype EffectStoreUsage =\n\t| typeof UNMANAGED\n\t| typeof MANAGED_COMPONENT\n\t| typeof MANAGED_HOOK;\n\nexport interface EffectStore {\n\t/**\n\t * An enum defining how this hook is used and whether it is invoked in a\n\t * component's body or hook body. See the comment on `EffectStoreUsage` for\n\t * more details.\n\t */\n\treadonly _usage: EffectStoreUsage;\n\treadonly effect: Effect;\n\tsubscribe(onStoreChange: () => void): () => void;\n\tgetSnapshot(): number;\n\t/** startEffect - begin tracking signals used in this component */\n\t_start(): void;\n\t/** finishEffect - stop tracking the signals used in this component */\n\tf(): void;\n\t[symDispose](): void;\n}\n\nlet currentStore: EffectStore | undefined;\n\nfunction startComponentEffect(\n\tprevStore: EffectStore | undefined,\n\tnextStore: EffectStore\n) {\n\tconst endEffect = nextStore.effect._start();\n\tcurrentStore = nextStore;\n\n\treturn finishComponentEffect.bind(nextStore, prevStore, endEffect);\n}\n\nfunction finishComponentEffect(\n\tthis: EffectStore,\n\tprevStore: EffectStore | undefined,\n\tendEffect: () => void\n) {\n\tendEffect();\n\tcurrentStore = prevStore;\n}\n\n/**\n * A redux-like store whose store value is a positive 32bit integer (a\n * 'version').\n *\n * React subscribes to this store and gets a snapshot of the current 'version',\n * whenever the 'version' changes, we tell React it's time to update the\n * component (call 'onStoreChange').\n *\n * How we achieve this is by creating a binding with an 'effect', when the\n * `effect._callback' is called, we update our store version and tell React to\n * re-render the component ([1] We don't really care when/how React does it).\n *\n * [1]\n * @see https://react.dev/reference/react/useSyncExternalStore\n * @see\n * https://github.com/reactjs/rfcs/blob/main/text/0214-use-sync-external-store.md\n *\n * @param _usage An enum defining how this hook is used and whether it is\n * invoked in a component's body or hook body. See the comment on\n * `EffectStoreUsage` for more details.\n */\nfunction createEffectStore(\n\t_usage: EffectStoreUsage,\n\tcomponentName?: string\n): EffectStore {\n\tlet effectInstance!: Effect;\n\tlet endEffect: (() => void) | undefined;\n\tlet version = 0;\n\tlet onChangeNotifyReact: (() => void) | undefined;\n\n\tlet unsubscribe = effect(\n\t\tfunction (this: Effect) {\n\t\t\teffectInstance = this;\n\t\t},\n\t\t{ name: componentName || \"Component\" }\n\t);\n\teffectInstance._callback = function () {\n\t\tversion = (version + 1) | 0;\n\t\tif (DEVTOOLS_ENABLED) {\n\t\t\teffectInstance._debugCallback?.call(effectInstance);\n\t\t}\n\t\tif (onChangeNotifyReact) onChangeNotifyReact();\n\t};\n\n\treturn {\n\t\t_usage,\n\t\teffect: effectInstance,\n\t\tsubscribe(onStoreChange) {\n\t\t\tonChangeNotifyReact = onStoreChange;\n\n\t\t\treturn function () {\n\t\t\t\t/**\n\t\t\t\t * Rotate to next version when unsubscribing to ensure that components are re-run\n\t\t\t\t * when subscribing again.\n\t\t\t\t *\n\t\t\t\t * In StrictMode, 'memo'-ed components seem to keep a stale snapshot version, so\n\t\t\t\t * don't re-run after subscribing again if the version is the same as last time.\n\t\t\t\t *\n\t\t\t\t * Because we unsubscribe from the effect, the version may not change. We simply\n\t\t\t\t * set a new initial version in case of stale snapshots here.\n\t\t\t\t */\n\t\t\t\tversion = (version + 1) | 0;\n\t\t\t\tonChangeNotifyReact = undefined;\n\t\t\t\tunsubscribe();\n\t\t\t};\n\t\t},\n\t\tgetSnapshot() {\n\t\t\treturn version;\n\t\t},\n\t\t_start() {\n\t\t\t// In general, we want to support two kinds of usages of useSignals:\n\t\t\t//\n\t\t\t// A) Managed: calling useSignals in a component or hook body wrapped in a\n\t\t\t//    try/finally (like what the react-transform plugin does)\n\t\t\t//\n\t\t\t// B) Unmanaged: Calling useSignals directly without wrapping in a\n\t\t\t//    try/finally\n\t\t\t//\n\t\t\t// For managed, we finish the effect in the finally block of the component\n\t\t\t// or hook body. For unmanaged, we finish the effect in the next\n\t\t\t// useSignals call or after a microtask.\n\t\t\t//\n\t\t\t// There are different tradeoffs which each approach. With managed, using\n\t\t\t// a try/finally ensures that only signals used in the component or hook\n\t\t\t// body are tracked. However, signals accessed in render props are missed\n\t\t\t// because the render prop is invoked in another component that may or may\n\t\t\t// not realize it is rendering signals accessed in the render prop it is\n\t\t\t// given.\n\t\t\t//\n\t\t\t// The other approach is \"unmanaged\": to call useSignals directly without\n\t\t\t// wrapping in a try/finally. This approach is easier to manually write in\n\t\t\t// situations where a build step isn't available but does open up the\n\t\t\t// possibility of catching signals accessed in other code before the\n\t\t\t// effect is closed (e.g. in a layout effect). Most situations where this\n\t\t\t// could happen are generally consider bad patterns or bugs. For example,\n\t\t\t// using a signal in a component and not having a call to `useSignals`\n\t\t\t// would be an bug. Or using a signal in `useLayoutEffect` is generally\n\t\t\t// not recommended since that layout effect won't update when the signals'\n\t\t\t// value change.\n\t\t\t//\n\t\t\t// To support both approaches, we need to track how each invocation of\n\t\t\t// useSignals is used, so we can properly transition between different\n\t\t\t// kinds of usages.\n\t\t\t//\n\t\t\t// The following table shows the different scenarios and how we should\n\t\t\t// handle them.\n\t\t\t//\n\t\t\t// Key:\n\t\t\t// 0 = UNMANAGED\n\t\t\t// 1 = MANAGED_COMPONENT\n\t\t\t// 2 = MANAGED_HOOK\n\t\t\t//\n\t\t\t// Pattern:\n\t\t\t// prev store usage -> this store usage: action to take\n\t\t\t//\n\t\t\t// - 0 -> 0: finish previous effect (unknown to unknown)\n\t\t\t//\n\t\t\t//   We don't know how the previous effect was used, so we need to finish\n\t\t\t//   it before starting the next effect.\n\t\t\t//\n\t\t\t// - 0 -> 1: finish previous effect\n\t\t\t//\n\t\t\t//   Assume previous invocation was another component or hook from another\n\t\t\t//   component. Nested component renders (renderToStaticMarkup within a\n\t\t\t//   component's render) won't be supported with bare useSignals calls.\n\t\t\t//\n\t\t\t// - 0 -> 2: capture & restore\n\t\t\t//\n\t\t\t//   Previous invocation could be a component or a hook. Either way,\n\t\t\t//   restore it after our invocation so that it can continue to capture\n\t\t\t//   any signals after we exit.\n\t\t\t//\n\t\t\t// - 1 -> 0: Do nothing. Signals already captured by current effect store\n\t\t\t// - 1 -> 1: capture & restore (e.g. component calls renderToStaticMarkup)\n\t\t\t// - 1 -> 2: capture & restore (e.g. hook)\n\t\t\t//\n\t\t\t// - 2 -> 0: Do nothing. Signals already captured by current effect store\n\t\t\t// - 2 -> 1: capture & restore (e.g. hook calls renderToStaticMarkup)\n\t\t\t// - 2 -> 2: capture & restore (e.g. nested hook calls)\n\n\t\t\tif (currentStore == undefined) {\n\t\t\t\tendEffect = startComponentEffect(undefined, this);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst prevUsage = currentStore._usage;\n\t\t\tconst thisUsage = this._usage;\n\n\t\t\tif (\n\t\t\t\t(prevUsage == UNMANAGED && thisUsage == UNMANAGED) || // 0 -> 0\n\t\t\t\t(prevUsage == UNMANAGED && thisUsage == MANAGED_COMPONENT) // 0 -> 1\n\t\t\t) {\n\t\t\t\t// finish previous effect\n\t\t\t\tcurrentStore.f();\n\t\t\t\tendEffect = startComponentEffect(undefined, this);\n\t\t\t} else if (\n\t\t\t\t(prevUsage == MANAGED_COMPONENT && thisUsage == UNMANAGED) || // 1 -> 0\n\t\t\t\t(prevUsage == MANAGED_HOOK && thisUsage == UNMANAGED) // 2 -> 0\n\t\t\t) {\n\t\t\t\t// Do nothing since it'll be captured by current effect store\n\t\t\t} else {\n\t\t\t\t// nested scenarios, so capture and restore the previous effect store\n\t\t\t\tendEffect = startComponentEffect(currentStore, this);\n\t\t\t}\n\t\t},\n\t\tf() {\n\t\t\tconst end = endEffect;\n\t\t\tendEffect = undefined;\n\t\t\tend?.();\n\t\t},\n\t\t[symDispose]() {\n\t\t\tthis.f();\n\t\t},\n\t};\n}\n\nconst noop = () => {};\n\nfunction createEmptyEffectStore(): EffectStore {\n\treturn {\n\t\t_usage: UNMANAGED,\n\t\teffect: {\n\t\t\t_sources: undefined,\n\t\t\t_callback() {},\n\t\t\t_start() {\n\t\t\t\treturn /* endEffect */ noop;\n\t\t\t},\n\t\t\t_dispose() {},\n\t\t},\n\t\tsubscribe() {\n\t\t\treturn /* unsubscribe */ noop;\n\t\t},\n\t\tgetSnapshot() {\n\t\t\treturn 0;\n\t\t},\n\t\t_start() {},\n\t\tf() {},\n\t\t[symDispose]() {},\n\t};\n}\n\nconst emptyEffectStore = createEmptyEffectStore();\n\nconst _queueMicroTask = Promise.prototype.then.bind(Promise.resolve());\n\nlet finalCleanup: Promise<void> | undefined;\nexport function ensureFinalCleanup() {\n\tif (!finalCleanup) {\n\t\tfinalCleanup = _queueMicroTask(cleanupTrailingStore);\n\t}\n}\nfunction cleanupTrailingStore() {\n\tfinalCleanup = undefined;\n\tcurrentStore?.f();\n}\n\nconst useIsomorphicLayoutEffect =\n\ttypeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n\n/**\n * Custom hook to create the effect to track signals used during render and\n * subscribe to changes to rerender the component when the signals change.\n */\nexport function _useSignalsImplementation(\n\t_usage: EffectStoreUsage = UNMANAGED,\n\tcomponentName?: string\n): EffectStore {\n\tensureFinalCleanup();\n\n\tconst storeRef = useRef<EffectStore>();\n\tif (storeRef.current == null) {\n\t\tif (typeof window === \"undefined\") {\n\t\t\tstoreRef.current = emptyEffectStore;\n\t\t} else {\n\t\t\tstoreRef.current = createEffectStore(_usage, componentName);\n\t\t}\n\t}\n\n\tconst store = storeRef.current;\n\tuseSyncExternalStore(store.subscribe, store.getSnapshot, store.getSnapshot);\n\tstore._start();\n\t// note: _usage is a constant here, so conditional is okay\n\tif (_usage === UNMANAGED) useIsomorphicLayoutEffect(cleanupTrailingStore);\n\n\treturn store;\n}\n\n/**\n * A wrapper component that renders a Signal's value directly as a Text node or JSX.\n */\nfunction SignalValue({ data }: { data: Signal }) {\n\tconst store = _useSignalsImplementation(1);\n\ttry {\n\t\treturn data.value;\n\t} finally {\n\t\tstore.f();\n\t}\n}\n\n// Decorate Signals so React renders them as <SignalValue> components.\nObject.defineProperties(Signal.prototype, {\n\t$$typeof: { configurable: true, value: ReactElemType },\n\ttype: { configurable: true, value: SignalValue },\n\tprops: {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn { data: this };\n\t\t},\n\t},\n\tref: { configurable: true, value: null },\n});\n\nexport function useSignals(\n\tusage?: EffectStoreUsage,\n\tcomponentName?: string\n): EffectStore {\n\treturn _useSignalsImplementation(usage, componentName);\n}\n\nexport function useSignal<T>(value: T, options?: SignalOptions<T>): Signal<T>;\nexport function useSignal<T = undefined>(): Signal<T | undefined>;\nexport function useSignal<T>(value?: T, options?: SignalOptions<T>) {\n\treturn useMemo(\n\t\t() => signal<T | undefined>(value, options as SignalOptions),\n\t\tEmpty\n\t);\n}\n\nexport function useComputed<T>(\n\tcompute: () => T,\n\toptions?: SignalOptions<T>\n): ReadonlySignal<T> {\n\tconst $compute = useRef(compute);\n\t$compute.current = compute;\n\treturn useMemo(() => computed<T>(() => $compute.current(), options), Empty);\n}\n\nexport function useSignalEffect(\n\tcb: () => void | (() => void),\n\toptions?: EffectOptions\n) {\n\tconst callback = useRef(cb);\n\tcallback.current = cb;\n\n\tuseEffect(() => {\n\t\treturn effect(function (this: Effect) {\n\t\t\treturn callback.current();\n\t\t}, options);\n\t}, Empty);\n}\n\ndeclare global {\n\tinterface Window {\n\t\t__PREACT_SIGNALS_DEVTOOLS__: SignalsDevToolsAPI;\n\t}\n}\n\n/** See comment in packages/core/src/index.ts on the same interface for an explanation */\ninterface InternalModelConstructor<TModel, TArgs extends any[]>\n\textends ModelConstructor<TModel, TArgs> {\n\t(...args: TArgs): Model<TModel>;\n}\n\nexport function useModel<TModel>(\n\tfactory: ModelConstructor<TModel, []> | (() => Model<TModel>)\n): Model<TModel> {\n\ttype InternalFactory =\n\t\t| InternalModelConstructor<TModel, []>\n\t\t| (() => Model<TModel>);\n\n\tconst [inst] = useState(() => (factory as InternalFactory)());\n\tuseEffect(() => inst[Symbol.dispose], [inst]);\n\treturn inst;\n}\n"],"names":["major","reactVersion","split","map","Number","Empty","ReactElemType","Symbol","for","DEVTOOLS_ENABLED","window","__PREACT_SIGNALS_DEVTOOLS__","wrapJsx","jsx","type","props","rest","i","v","Signal","value","call","symDispose","dispose","currentStore","startComponentEffect","prevStore","nextStore","endEffect","effect","_start","finishComponentEffect","bind","noop","emptyEffectStore","_usage","_sources","undefined","_callback","_dispose","subscribe","getSnapshot","f","_queueMicroTask","Promise","prototype","then","resolve","finalCleanup","ensureFinalCleanup","cleanupTrailingStore","_currentStore","useIsomorphicLayoutEffect","useLayoutEffect","useEffect","_useSignalsImplementation","componentName","storeRef","useRef","current","effectInstance","onChangeNotifyReact","version","unsubscribe","this","name","_effectInstance$_debu","_debugCallback","onStoreChange","prevUsage","thisUsage","end","createEffectStore","store","useSyncExternalStore","Object","defineProperties","$$typeof","configurable","data","get","ref","useSignals","usage","useSignal","options","useMemo","signal","useComputed","compute","$compute","computed","useSignalEffect","cb","callback","useModel","factory","inst","useState"],"mappings":"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"}},
    {"offset": {"line": 718, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Documents/react-project/timesheet/node_modules/@preact/signals-react/dist/signals.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":""}}]
}